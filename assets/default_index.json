{"Tutorial 1: Your first effect":{"KnobName1":"","KnobDefaultValue0":"0.500000","KnobName0":"","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 1: Your first effect\r\n\r\n    Welcome to Formula!\r\n    In this tutorial you will learn the structure\r\n    of a basic effect: we will create a simple gain booster.\r\n    \r\n    NOTE: Formulas are made using the C programming language, we advise you to learn the most\r\n    basic features of that language (variables, operations, conditions).\r\n\r\n    An audio signal is made of a sequence of samples.\r\n    \r\n    All the code you put between 'formula_main {' and '}' will be executed for each sample.\r\n    \r\n    You want to process each input sample and return it as a modified output sample.\r\n    \r\n    Inside formula_main, you can access your input sample as the float variable 'input'.\r\n    Here, we multiply the input sample by 2, hence doubling the gain of our input.\r\n    \r\n    The result is stored in a new variable 'boostedInput', and we use the \r\n    'return' keyword to return this variable as our modified output.\r\n*/\r\n\nformula_main {\n    float boostedInput = input * 2;\r\n    \n    return boostedInput;\n}\r\n\r\n/* Try changing the gain value, hit the play button in Formula and play a sound in your track! */","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 1: Your first effect","KnobDefaultValue9":"0.500000","CompilationId":"fe3ebea6-0b18-4e69-bd69-81a020b23972","Description":"You will learn the structure of a basic effect: we will create a simple gain booster.","Created":"2022-May-29 11:53:42","LastModified":"2022-May-29 18:10:24","SwitchName1":"","SwitchDefaultValue0":"","SwitchDefaultValue1":"","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 2: Using controls":{"KnobName1":"","KnobDefaultValue0":"0.500000","KnobName0":"Gain","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 2: Using controls\r\n\r\n    In this tutorial you will learn to make your effect react to the controls in the knobs panel.\r\n    \r\n    You can open the knob panel by clicking the blue button in the bottom of the side bar.\r\n    Knobs labels can be customized and the knobs labels and values will be saved along with your formula.\r\n\r\n    In your formula, you can access the 12 different knobs using the values KNOB_1, KNOB_2, ..., KNOB_12.\r\n    The knobs will always have a value between 0 (0%) and 1 (100%).\r\n    \r\n    You can also access the 3 switches using SWITCH_1, SWITCH2 and SWITCH_3.\r\n    The value of a switch will be either 0 (off) or 1 (on).\r\n    \r\n    Here, we will use the first switch to determine if we want to do a gain boost or a gain reduction.\r\n    We will also use the first knob to get the amount of gain we want.\r\n       \r\n    -> If the switch is checked, it is a gain reduction: we enter the first branch of the condition.\r\n    We will use our first knob to multiply the input: \r\n        - If the knob is at 0%, then 1 - KNOB_1 = 1 and our output will be equal to our input. \r\n        - If the knob is at 50%, then 1 - KNOB_1 = 0.5 so our output two times lower. \r\n        - If the knob is at 100%, then 1 - KNOB_1 = 0 and our output will be completly muted.\r\n        \r\n    -> If the switch is unchecked, it is a gain boost: we enter the else branch.\r\n        - If the knob is at 0%, then 1 - KNOB_1 = 1 and our output will be equal to our input.\r\n        - If the knob is at 50%, then 1 - KNOB_1 = 0.5 so our output two times higher.\r\n        - If the knob is at 100%, then 1 - KNOB_1 = 0 and our output have an infinite gain.\r\n*/\r\n\nformula_main {\r\n    float output;\r\n    \r\n    int isGainReduction = SWITCH_1;\r\n    \r\n    if (isGainReduction) {\r\n        output = input * (1 - KNOB_1);\r\n    }\r\n    else {\r\n        float maxGain = 5;\n        output = input / (1 - KNOB_1);\r\n    }\r\n    \n    return output;\n}\r\n\r\n/* All the knobs and switches can be automated in your DAW! */","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"...","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 2: Using controls","KnobDefaultValue9":"0.500000","CompilationId":"c2f6d792-5539-4dca-8045-3aad8ab7a2ad","Description":"You will learn to make your effect react to the controls in the knob panel.","Created":"2022-May-29 15:45:50","LastModified":"2022-May-29 20:27:29","SwitchDefaultValue0":"0","SwitchName1":"","SwitchName0":"Boost / Cut","SwitchDefaultValue1":"0","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 3: Math functions":{"KnobName1":"","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 3: Math functions\r\n\r\n    In this tutorial you will learn how to use standard math functions.\r\n    \r\n    Our previous effect had an issue: we had to use a switch to create either\r\n    a gain boost or a gain cut, and we did not have control over our maximum allowed gain.\r\n    \r\n    Hence, we will read the knob value in decibels and we will convert it to a gain.\r\n    To do so, we use the mathematical formula :\r\n        gain = 10^(decibels / 20)\r\n    \r\n    There is no built-in operator in the C language to make a power.\r\n    Hopefully, the standard mathematical library is shipped with the formulas!\r\n    You can find the list of all of its functions here: https://en.wikipedia.org/wiki/C_mathematical_functions\r\n    \r\n    Thus, we can use the 'pow(X, Y)' function to do our calculation. \r\n*/\r\n\nformula_main {\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n\r\n    float boostedOutput = input * gain;\r\n    \n    return boostedOutput;\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 3: Math functions","KnobDefaultValue9":"0.500000","CompilationId":"e42ee789-2434-42f5-a479-756b3576fc54","Description":"You will learn how to use standard math functions.","Created":"2022-May-29 16:00:56","LastModified":"2022-May-29 20:31:56","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 4: Using time":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 4: Using time\r\n\r\n    In this tutorial you will learn how to make your formula react to the time.\r\n    \r\n    We are going to convert our simple gain plugin to an tremolo.\r\n    To do so, the gain must be modulated by an LFO.\r\n    \r\n    We will use the second knob to read the frequency for our LFO, from 0 to 10Hz.\r\n    \r\n    Then, we will create a sine wave oscillating between 0 and 1 at the frequency coming from this knob,\r\n    using the TIME value which is the amount of seconds elapsed since the launch of our plugin.\r\n    \r\n    This LFO will be multiplicated by our gain coming from the first knob, and applied to our input sample.\r\n*/\r\n\nformula_main {\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n    \r\n    float lfoFrequency = KNOB_2 * 10; // From 0 to 10Hz\r\n    float lfo = gain * sin(2 * M_PI * lfoFrequency * TIME);\r\n    \r\n    float output = input * lfo;\r\n    \n    return output;\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 4: Using time","KnobDefaultValue9":"0.500000","CompilationId":"63a5e825-1d47-4a35-86fa-01a5f65cab58","Description":"You will learn how to make your formula react to the time.","Created":"2022-May-29 16:12:06","LastModified":"2022-May-29 20:34:27","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 5: State management using globals":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 5: State management using globals\r\n\r\n    In this tutorial you will learn how you can store a value for later use.\r\n    \r\n    Sometimes, you need to compute a value using a sample and get this value back some time after.\r\n    To do so in a formula, you would declare a global variable outside of the 'formula_main {...}' block.\r\n    \r\n    Such a variable will be defined once at startup, and you could read and/or write to it in the formula_main\r\n    block. The difference with a local variable is that the value of this global variable would not be\r\n    discarded at the end of the 'formula_main' block.\r\n    \r\n    Let's add a low-pass filter on top of our LFO. \r\n    The technical implementation is out of scope, but keep in mind that such a filter\r\n    needs to know its output from the previous sample.\r\n    \r\n    What we will do, is to create a global variable called 'previousOutput'.\r\n    We will use this variable for our filter processing, and update it once we are done.\r\n    \r\n    Note that we also use the SAMPLE_RATE value, often essential to produce an invariant processing for \r\n    any sample rate coming from the host.\r\n*/\r\n\r\nfloat previousOutput = 0;\r\n\nformula_main {\r\n    // Gain section\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n    \r\n    // LFO section\r\n    float lfoFrequency = KNOB_2 * 10; // From 0 to 10Hz\r\n    float lfo = gain * sin(2 * M_PI * lfoFrequency * TIME);    \r\n    float lfoOutput = input * lfo;    \r\n    \r\n    // Filter section\r\n    float filterFrequency = 20 + KNOB_3 * 20000; // From 20Hz to 20kHz\r\n    float alpha = exp(-filterFrequency / SAMPLE_RATE);\r\n    float filterOutput = previousOutput * alpha + lfoOutput * (1 - alpha);\r\n    previousOutput = filterOutput;\r\n    \n    return filterOutput;\n}\r\n\r\n/* NOTES: \r\n    - Don't forget to initialize your global variables!\r\n    - If you declare a local variable with the same name than a global, it will overwrite it\r\n    without throwing any error!\r\n*/","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 5: State management using globals","KnobDefaultValue9":"0.500000","CompilationId":"4014377b-72a7-4251-b0fa-299dc629aa0f","Description":"You will learn how you can store a value for later use.","Created":"2022-May-29 16:33:00","LastModified":"2022-May-29 20:37:38","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 6: Going stereo":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"Panning","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 6: Going stereo\r\n\r\n    In this tutorial you will learn how to produce a different output for the left and right channels.\r\n    \r\n    Until now, all the tutorial effects were invariantly repeated for every audio channel. \r\n    But sometimes, you need to control the left and right channels independently.\r\n    \r\n    In a formula, you would use a 'formula_main_stereo {...}' block instead. The input variable would\r\n    not be a simple float value, but a Stereo variable holding two members: input.left and input.right.\r\n    \r\n    In the same way, the output that you will return has to be a Stereo variable.\r\n*/\r\n\r\nfloat previousOutput[2] = {0};\r\n\nformula_main_stereo {\r\n    // Gain section\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n    \r\n    // LFO section\r\n    float lfoFrequency = KNOB_2 * 10; // From 0 to 10Hz\r\n    float lfo = gain * sin(2 * M_PI * lfoFrequency * TIME);\r\n    float lfoOutputLeft = input.left * lfo;    \r\n    float lfoOutputRight = input.right * lfo; \r\n    \r\n    // Filter section\r\n    float filterFrequency = 20 + KNOB_3 * 20000; // From 20Hz to 20kHz\r\n    float alpha = exp(-filterFrequency / SAMPLE_RATE);\r\n    float filterOutputLeft = previousOutput[0] * alpha + lfoOutputLeft * (1 - alpha);\r\n    float filterOutputRight = previousOutput[1] * alpha + lfoOutputRight * (1 - alpha);\r\n    previousOutput[0] = filterOutputLeft;\r\n    previousOutput[1] = filterOutputRight;\r\n    \r\n    // Panning section\r\n    float panning = KNOB_4; // 0% = Left, 100% = Right\r\n    float panningOutputLeft = filterOutputLeft * (1 - panning);\r\n    float panningOutputRight = filterOutputRight * panning;\r\n    \r\n    Stereo output;\r\n    output.left = panningOutputLeft;\r\n    output.right = panningOutputRight;\r\n    \n    return output;\n}\r\n\r\n/* NOTES:\r\n    - We used an array to store the filter state, it is often more handy when working with\r\n    multiple channels.\r\n*/","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 6: Going stereo","KnobDefaultValue9":"0.500000","CompilationId":"1841c7b0-fa12-4da0-ae07-0cc1644a3dcc","Description":"You will learn how to produce a different output for the left and right channels.","Created":"2022-May-29 17:11:26","LastModified":"2022-May-29 20:38:57","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 7: Advanced concepts":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 7: Advanced concepts\r\n\r\n    In this tutorial you will learn about some more advanced features of Formula.\r\n    \r\n    1) Differences with C language\r\n    Formula uses a C language compiler, but there are some restrictions that apply, mostly\r\n    for security or compatibility reasons:\r\n        - You can't use the C preprocessor. If you want to #include an external library, it is not possible.\r\n        As of now, only stdlib.h and math.h are included by default.\r\n        - You can't use dynamic memory allocation at all.\r\n        \r\n    Note that if you wish to use Formula through a private Formula Cloud tenant for your company, \r\n    Soundspear can provide you a custom build where all of those restrictions are removed, \r\n    and with additional features such as C++ support and custom compilers.\r\n    \r\n    2) Debugging formulas\r\n    You might want to debug a formula if it is not doing what it is intended to do.\r\n    You can use the DEBUG(x) macro to do so: the variable you are passing to the macro will\r\n    be dumped at a fixed interval of time and you will be able to see its value using the Debug pane by\r\n    clicking on the bug icon from the sidebar.\r\n    \r\n    3) Performance\r\n    The tutorials were not focused on performance, but keep in mind that your code will run at least\r\n    44100 times per second, hence performance should be one of your primary concerns. A good practice\r\n    is to recompute most of values only if absolutly necessary, for instance if the knobs have changed.\r\n    \r\n    4) Create a VST from a formula\r\n    A formula can be compiled as C code given a library called libformula.h, that you can find in \r\n    our Github repository.\r\n*/\r\n\r\n\nformula_main {\r\n    DEBUG(input);\r\n    \r\n    return input;\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 7: Advanced concepts","KnobDefaultValue9":"0.500000","CompilationId":"6eaff75c-fda0-4a39-904b-dc701ccfab5a","Description":"You will learn about some more advanced features of Formula.","Created":"2022-May-29 17:58:53","LastModified":"2022-May-29 20:41:00","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 8: What is Formula Cloud":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 8: What is Formula Cloud\r\n\r\n    Creating your own formulas are great, but testing formulas from the community is \r\n    even better.\r\n    \r\n    This is happening on Formula Cloud, under the third tab of this plugin.\r\n    \r\n    You can dig through hundred of innovative formulas and pick the one you need.\r\n    \r\n    You can also share any of the formulas you made from the 'Saved files' tab.\r\n    \r\n    NOTE: Formula Cloud is a paid feature available as a subscription on soundspear.com\r\n*/\r\n\r\n\nformula_main { return input; }\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 8: What is Formula Cloud","KnobDefaultValue9":"0.500000","CompilationId":"6eaff75c-fda0-4a39-904b-dc701ccfab5a","Description":"You will be given an overview of Formula Cloud.","Created":"2022-May-29 20:46:31","LastModified":"2022-May-29 20:47:54","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Warmifier":{"KnobName1":"","KnobDefaultValue0":"1.000000","KnobName0":"Drive","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"/* --------------------------------- *\r\n *            Warmifier              *\r\n *                                   *\r\n * Creates a warm tone full of even  *\r\n * harmonics as in traditional tube  *\r\n * distortion.                       *\r\n *                                   *\r\n * --------------------------------- */\r\n\r\n\r\n// This type contains the state and the coefficients of a\r\n// band split crossover filter\r\ntypedef struct {\r\n    float c[2][2][6];      // [lo/hi][order][coeff]\r\n    float zIn[2][2][2];    // [lo/hi][order][input delay]\r\n    float zOut[2][2][2];   // [lo/hi][order][output delay]\r\n} LRState;\r\n\r\n// Splits an input sample into a low and a high sample using a crossover\r\nLRState xOver(float input, float* outLow, float* outHigh, LRState state) {\r\n    \r\n    float inLow = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[0][order], *b = state.c[0][order] + 3;\r\n        float *i = state.zIn[0][order], *o = state.zOut[0][order];\r\n        *outLow = (b[0]*inLow + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inLow;\r\n        o[1] = o[0]; o[0] = *outLow;\r\n        inLow = *outLow;\r\n    }\r\n    \r\n    float inHigh = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[1][order], *b = state.c[1][order] + 3;\r\n        float *i = state.zIn[1][order], *o = state.zOut[1][order];\r\n        *outHigh = (b[0]*inHigh + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inHigh;\r\n        o[1] = o[0]; o[0] = *outHigh;\r\n        inHigh = *outHigh;\r\n    }\r\n    return state;\r\n}\r\n\r\n// Initializes the coefficients for a 4th order Linqwitz-Riley crossover\r\nLRState lr4(float cutoff, LRState state) {\r\n    float Q = 1 / sqrt(2);\r\n    for (int i = 0; i < 2; ++i)\r\n    {\r\n        float w0 = 2 * M_PI * cutoff / SAMPLE_RATE;\r\n        float alpha = sin(w0) / (2*Q);\r\n        float cw = cos(w0);\r\n        \r\n        state.c[1][i][0] = state.c[0][i][0] = 1 + alpha;\r\n        state.c[1][i][1] = state.c[0][i][1] = -2 * cw;\r\n        state.c[1][i][2] = state.c[0][i][2] = 1 - alpha;        \r\n        state.c[0][i][3] = 0.5 * (1 - cw);\r\n        state.c[1][i][3] = 0.5 * (1 + cw);\r\n        state.c[0][i][4] = 1 - cw;\r\n        state.c[1][i][4] = -1 - cw;\r\n        state.c[0][i][5] = 0.5 * (1 - cw);\r\n        state.c[1][i][5] = 0.5 * (1 + cw);\r\n    }\r\n    \r\n    return state;\r\n}\r\n\r\n// To initialize the filter only once at startup\r\nint xoverInitialized = 0;\r\n\r\n// High/low crossover\r\nLRState xoverState = {{0}};\r\n// Antialiasing filter\r\nLRState antialias = {{0}};\r\n\nformula_main {\r\n\r\n    if (!xoverInitialized) {\r\n        // Initialize the crossover to split bands at 1500 Hz\r\n        xoverState = lr4(1500, xoverState);\r\n        // Initialize the antialiasing filter at 15 kHz\r\n        antialias = lr4(15000, antialias);\r\n        xoverInitialized = 1;\r\n    }\r\n\n    float high, low;\r\n    xoverState = xOver(input, &low, &high, xoverState);\r\n    \r\n    float drive = KNOB_1*0.5 + 0.5;\r\n    \r\n    // Apply an even-harmonics waveshaper to the negatively polarized samples\r\n    float x = low, x2 = x*x, x3 = x2*x;\r\n    \r\n    if (x < -0.8) {\r\n        low = 0.2533783783783784*x3 + 0.7601351351351351*x2 + x - 0.5067567567567568;\r\n        low *= drive;\r\n    }\r\n    else if (x < -0.4) {\r\n        low = 1.8369932432432432*x3 + 4.5608108108108105*x2 + 4.04054054054054*x + 0.30405405405405406;\r\n        low *= drive;\r\n    }\r\n    else if (x < 0) {\r\n        low = -2.9138513513513513*x3 - 1.1402027027027026*x2 + 1.760135135135135*x;\r\n        low *= drive;\r\n    }\r\n    else {\r\n        low = x;\r\n    }\r\n    \r\n    // Apply antialiasing\n    float keep, discard;    \r\n    antialias = xOver(low, &keep, &discard, antialias);\r\n    low = keep;\r\n    \r\n    return low + high * (1 + 0.3*(drive-0.5));\n}\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Warmifier","KnobDefaultValue9":"0.500000","CompilationId":"0387a4b8-ab39-48df-b116-cd4d825563ca","Description":"Creates a warm tone full of even harmonics as in traditional tube distortion.","Created":"2022-Jun-04 15:51:13","LastModified":"2022-Jun-04 21:15:35","SwitchName1":"","SwitchDefaultValue0":"","SwitchDefaultValue1":"","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":""},"Ultra Punch":{"KnobName1":"","KnobDefaultValue0":"1.000000","KnobName0":"Punch","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"/* --------------------------------- *\r\n *          Ultra Punch              *\r\n *                                   *\r\n * Squashes a band limited input to  *\r\n * extract the juiciest punch of it. *\r\n *                                   *\r\n * --------------------------------- */\r\n \r\n \r\n \r\n// Slow, RMS style downward compressor state structure\r\ntypedef struct {\r\n    double thres, ratio, atk, rel;\r\n    double makeup, rmsSize;\r\n\r\n    double rmsBuf[10000];\r\n    double rmsSum; \r\n\tint rmsPtr;\r\n    double yold;\r\n} CompState;\r\n\r\n// Compute the RMS average from an input and a previous state\r\nfloat computeRms(float input, CompState* s) {\r\n    s->rmsSum -= s->rmsBuf[s->rmsPtr];\r\n    s->rmsBuf[s->rmsPtr] = input*input/s->rmsSize;    \r\n    s->rmsSum += s->rmsBuf[s->rmsPtr++];\r\n    \r\n    if (s->rmsPtr > s->rmsSize) {\r\n        s->rmsPtr = 0;\r\n    }\r\n    \r\n    float rms = sqrt(s->rmsSum);\r\n\t\r\n\treturn rms;\r\n}\r\n\r\n// Compress the input given the characteristics from CompState\r\nfloat compress(float input, CompState* s) {    \r\n    double rms = computeRms(input, s);  \r\n    \r\n    double x = fabs(rms);\r\n    double cte = x > s->yold ? s->atk : s->rel;\r\n    double y = x + cte * (s->yold - x);\r\n    s->yold = y;\r\n    \r\n    double gain = 1.0;\r\n    if (y > s->thres) {\r\n        gain = pow (y / s->thres, 1.0 / s->ratio - 1.0);\r\n    }    \r\n    \r\n    return gain * input * s->makeup; \r\n}\r\n\r\n// Create / Update a compressor state with given characteristics\r\nvoid updateComp(CompState* s, float thresDb, float ratio, float atkMs, float relMs, float makeupDb, float rmsSize) {\r\n    s->thres = pow (10.0, thresDb * 0.05);\r\n    s->ratio = ratio;\r\n    double scaling = -2.0 * M_PI * 1000.0 / SAMPLE_RATE;\r\n    s->atk = exp(scaling / atkMs);\r\n    s->rel = exp(scaling / relMs);\r\n    s->makeup = pow (10.0, makeupDb * 0.05);\r\n    s->rmsSize = rmsSize;\r\n}\r\n\r\n// This type contains the state and the coefficients of a\r\n// band split crossover filter\r\ntypedef struct {\r\n    float c[2][2][6];      // [lo/hi][order][coeff]\r\n    float zIn[2][2][2];    // [lo/hi][order][input delay]\r\n    float zOut[2][2][2];   // [lo/hi][order][output delay]\r\n} LRState;\r\n\r\n// Splits an input sample into a low and a high sample using a crossover\r\nLRState xOver(float input, float* outLow, float* outHigh, LRState state) {\r\n    \r\n    float inLow = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[0][order], *b = state.c[0][order] + 3;\r\n        float *i = state.zIn[0][order], *o = state.zOut[0][order];\r\n        *outLow = (b[0]*inLow + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inLow;\r\n        o[1] = o[0]; o[0] = *outLow;\r\n        inLow = *outLow;\r\n    }\r\n    \r\n    float inHigh = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[1][order], *b = state.c[1][order] + 3;\r\n        float *i = state.zIn[1][order], *o = state.zOut[1][order];\r\n        *outHigh = (b[0]*inHigh + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inHigh;\r\n        o[1] = o[0]; o[0] = *outHigh;\r\n        inHigh = *outHigh;\r\n    }\r\n    return state;\r\n}\r\n\r\n// Initializes the coefficients for a 4th order Linqwitz-Riley crossover\r\nLRState lr4(float cutoff, LRState state) {\r\n    float Q = 1 / sqrt(2);\r\n    for (int i = 0; i < 2; ++i)\r\n    {\r\n        float w0 = 2 * M_PI * cutoff / SAMPLE_RATE;\r\n        float alpha = sin(w0) / (2*Q);\r\n        float cw = cos(w0);\r\n        \r\n        state.c[1][i][0] = state.c[0][i][0] = 1 + alpha;\r\n        state.c[1][i][1] = state.c[0][i][1] = -2 * cw;\r\n        state.c[1][i][2] = state.c[0][i][2] = 1 - alpha;        \r\n        state.c[0][i][3] = 0.5 * (1 - cw);\r\n        state.c[1][i][3] = 0.5 * (1 + cw);\r\n        state.c[0][i][4] = 1 - cw;\r\n        state.c[1][i][4] = -1 - cw;\r\n        state.c[0][i][5] = 0.5 * (1 - cw);\r\n        state.c[1][i][5] = 0.5 * (1 + cw);\r\n    }\r\n    \r\n    return state;\r\n}\r\n\r\n// To initialize the filter only once at startup\r\nint xoverInitialized = 0;\r\n\r\nfloat prevThres = 1;\r\n\r\nLRState xbass = {{0}};\r\nLRState xhigh = {{0}};\r\nCompState compBass = {{0}}, compMid = {{0}}, compHigh = {{0}};\r\n\r\nformula_main {\r\n\r\n    if (!xoverInitialized) {\r\n        xbass = lr4(150, xbass);\r\n        xhigh = lr4(2500, xhigh);\r\n    }\r\n    if (prevThres != KNOB_1 * -20) {\r\n        updateComp(&compBass, KNOB_1 * -30, 2, 5, 20, KNOB_1 * 6, 10);\r\n        updateComp(&compMid, KNOB_1 * -30, 3, 5, 10, KNOB_1 * 2.5, 3);\r\n        updateComp(&compHigh, KNOB_1 * -30, 10, 15, 50, KNOB_1 * 2.5, 100);\r\n        prevThres = KNOB_1 * -20;   \r\n    }\r\n    \r\n    float bass, mid, high;\r\n    \r\n    xbass = xOver(input, &bass, &mid, xbass);\r\n    xhigh = xOver(mid, &mid, &high, xhigh);    \r\n    \r\n    bass = compress(bass, &compBass);    \r\n    mid = compress(mid, &compMid);\r\n    high = compress(high, &compHigh);\r\n    \r\n    return bass + mid + high;\r\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","Name":"Ultra Punch","KnobName8":"","KnobDefaultValue9":"0.500000","CompilationId":"69093bce-02df-4860-9fc3-7103982b0dea","SwitchName1":"","SwitchDefaultValue0":"0","SwitchName0":"","SwitchDefaultValue1":"0","Description":"Squashes a band limited input to extract the juiciest punch of it.","Created":"2022-Jun-12 13:31:52","LastModified":"2022-Jun-12 13:31:52","SwitchDefaultValue2":"0","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":""},"FireAmp (Airwindows)":{"KnobName1":"Tone","KnobDefaultValue0":"0.500000","KnobName0":"Gain","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.800000","KnobName2":"Output","Source":"/* ========================================\r\n *  FireAmp - FireAmp.h\r\n *  Copyright (c) 2016 airwindows, All rights reserved\r\n * ======================================== */\r\n\r\ndouble lastSampleL = 0.0;\r\ndouble storeSampleL = 0.0;\r\ndouble smoothAL = 0.0;\r\ndouble smoothBL = 0.0;\r\ndouble smoothCL = 0.0;\r\ndouble smoothDL = 0.0;\r\ndouble smoothEL = 0.0;\r\ndouble smoothFL = 0.0;\r\ndouble smoothGL = 0.0;\r\ndouble smoothHL = 0.0;\r\ndouble smoothIL = 0.0;\r\ndouble smoothJL = 0.0;\r\ndouble smoothKL = 0.0;\r\ndouble smoothLL = 0.0;\r\ndouble iirSampleAL = 0.0;\r\ndouble iirSampleBL = 0.0;\r\ndouble iirSampleCL = 0.0;\r\ndouble iirSampleDL = 0.0;\r\ndouble iirSampleEL = 0.0;\r\ndouble iirSampleFL = 0.0;\r\ndouble iirSampleGL = 0.0;\r\ndouble iirSampleHL = 0.0;\r\ndouble iirSampleIL = 0.0;\r\ndouble iirSampleJL = 0.0;\r\ndouble iirSampleKL = 0.0;\r\ndouble iirSampleLL = 0.0;\r\ndouble iirLowpassL = 0.0;\r\ndouble iirSpkAL = 0.0;\r\ndouble iirSpkBL = 0.0;\r\ndouble iirSubL = 0.0;\r\ndouble OddL[257] = {0.0};\r\ndouble EvenL[257] = {0.0};\r\n\r\ndouble lastSampleR = 0.0;\r\ndouble storeSampleR = 0.0;\r\ndouble smoothAR = 0.0;\r\ndouble smoothBR = 0.0;\r\ndouble smoothCR = 0.0;\r\ndouble smoothDR = 0.0;\r\ndouble smoothER = 0.0;\r\ndouble smoothFR = 0.0;\r\ndouble smoothGR = 0.0;\r\ndouble smoothHR = 0.0;\r\ndouble smoothIR = 0.0;\r\ndouble smoothJR = 0.0;\r\ndouble smoothKR = 0.0;\r\ndouble smoothLR = 0.0;\r\ndouble iirSampleAR = 0.0;\r\ndouble iirSampleBR = 0.0;\r\ndouble iirSampleCR = 0.0;\r\ndouble iirSampleDR = 0.0;\r\ndouble iirSampleER = 0.0;\r\ndouble iirSampleFR = 0.0;\r\ndouble iirSampleGR = 0.0;\r\ndouble iirSampleHR = 0.0;\r\ndouble iirSampleIR = 0.0;\r\ndouble iirSampleJR = 0.0;\r\ndouble iirSampleKR = 0.0;\r\ndouble iirSampleLR = 0.0;\r\ndouble iirLowpassR = 0.0;\r\ndouble iirSpkAR = 0.0;\r\ndouble iirSpkBR = 0.0;\r\ndouble iirSubR = 0.0;\r\ndouble OddR[257] = {0.0};\r\ndouble EvenR[257] = {0.0};\r\n\r\nint flip = 0;\r\nint count = 0; //amp\r\n\r\ndouble bL[90] = {0.0};\r\ndouble lastCabSampleL = 0.0;\r\ndouble smoothCabAL = 0.0;\r\ndouble smoothCabBL = 0.0; //cab\r\n\r\ndouble bR[90] = {0.0};\r\ndouble lastCabSampleR = 0.0;\r\ndouble smoothCabAR = 0.0;\r\ndouble smoothCabBR = 0.0; //cab\r\n\r\ndouble lastRefL[10] = {0.0};\r\ndouble lastRefR[10] = {0.0};\r\nint cycle = 0;\t//undersampling\r\n\r\nenum {\r\n\tfix_freq,\r\n\tfix_reso,\r\n\tfix_a0,\r\n\tfix_a1,\r\n\tfix_a2,\r\n\tfix_b1,\r\n\tfix_b2,\r\n\tfix_sL1,\r\n\tfix_sL2,\r\n\tfix_sR1,\r\n\tfix_sR2,\r\n\tfix_total\r\n}; //fixed frequency biquad filter for ultrasonics, stereo\r\ndouble fixA[fix_total] = {0.0};\r\ndouble fixB[fix_total] = {0.0};\r\ndouble fixC[fix_total] = {0.0};\r\ndouble fixD[fix_total] = {0.0};\r\ndouble fixE[fix_total] = {0.0};\r\ndouble fixF[fix_total] = {0.0}; //filtering\r\n\r\nuint32_t fpdL = 0xdeadbeef;\r\nuint32_t fpdR = 0xcafebabe;\r\n//default stuff\r\n\r\n\t\r\nformula_main_stereo {\r\n\r\n\tdouble bassfill = KNOB_1;\r\n\tdouble outputlevel = KNOB_3;\r\n\t\r\n\tdouble overallscale = 1.0;\r\n\toverallscale /= 44100.0;\r\n\toverallscale *= SAMPLE_RATE;\r\n\tint cycleEnd = floor(overallscale);\r\n\tif (cycleEnd < 1) cycleEnd = 1;\r\n\tif (cycleEnd > 4) cycleEnd = 4;\r\n\t//this is going to be 2 for 88.1 or 96k, 3 for silly people, 4 for 176 or 192k\r\n\tif (cycle > cycleEnd-1) cycle = cycleEnd-1; //sanity check\t\t\r\n\t\r\n\tdouble startlevel = bassfill;\r\n\tdouble samplerate = SAMPLE_RATE;\r\n\tdouble basstrim = bassfill / 16.0;\r\n\tdouble toneEQ = (KNOB_2 / samplerate)*22050.0;\r\n\tdouble EQ = (basstrim / samplerate)*22050.0;\r\n\tdouble bleed = outputlevel/16.0;\r\n\tdouble bassfactor = 1.0-(basstrim*basstrim);\r\n\tdouble BEQ = (bleed / samplerate)*22050.0;\r\n\tint diagonal = (int)(0.000861678*samplerate);\r\n\tif (diagonal > 127) diagonal = 127;\r\n\tint side = (int)(diagonal/1.4142135623730951);\r\n\tint down = (side + diagonal)/2;\r\n\t//now we've got down, side and diagonal as offsets and we also use three successive samples upfront\r\n\t\r\n\tdouble cutoff = (15000.0+(KNOB_2*10000.0)) / SAMPLE_RATE;\r\n\tif (cutoff > 0.49) cutoff = 0.49; //don't crash if run at 44.1k\r\n\tif (cutoff < 0.001) cutoff = 0.001; //or if cutoff's too low\r\n\t\r\n\tfixF[fix_freq] = fixE[fix_freq] = fixD[fix_freq] = fixC[fix_freq] = fixB[fix_freq] = fixA[fix_freq] = cutoff;\r\n\t\r\n    fixA[fix_reso] = 4.46570214;\r\n\tfixB[fix_reso] = 1.51387132;\r\n\tfixC[fix_reso] = 0.93979296;\r\n\tfixD[fix_reso] = 0.70710678;\r\n\tfixE[fix_reso] = 0.52972649;\r\n\tfixF[fix_reso] = 0.50316379;\r\n\t\r\n\tdouble K = tan(M_PI * fixA[fix_freq]); //lowpass\r\n\tdouble norm = 1.0 / (1.0 + K / fixA[fix_reso] + K * K);\r\n\tfixA[fix_a0] = K * K * norm;\r\n\tfixA[fix_a1] = 2.0 * fixA[fix_a0];\r\n\tfixA[fix_a2] = fixA[fix_a0];\r\n\tfixA[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixA[fix_b2] = (1.0 - K / fixA[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixB[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixB[fix_reso] + K * K);\r\n\tfixB[fix_a0] = K * K * norm;\r\n\tfixB[fix_a1] = 2.0 * fixB[fix_a0];\r\n\tfixB[fix_a2] = fixB[fix_a0];\r\n\tfixB[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixB[fix_b2] = (1.0 - K / fixB[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixC[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixC[fix_reso] + K * K);\r\n\tfixC[fix_a0] = K * K * norm;\r\n\tfixC[fix_a1] = 2.0 * fixC[fix_a0];\r\n\tfixC[fix_a2] = fixC[fix_a0];\r\n\tfixC[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixC[fix_b2] = (1.0 - K / fixC[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixD[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixD[fix_reso] + K * K);\r\n\tfixD[fix_a0] = K * K * norm;\r\n\tfixD[fix_a1] = 2.0 * fixD[fix_a0];\r\n\tfixD[fix_a2] = fixD[fix_a0];\r\n\tfixD[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixD[fix_b2] = (1.0 - K / fixD[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixE[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixE[fix_reso] + K * K);\r\n\tfixE[fix_a0] = K * K * norm;\r\n\tfixE[fix_a1] = 2.0 * fixE[fix_a0];\r\n\tfixE[fix_a2] = fixE[fix_a0];\r\n\tfixE[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixE[fix_b2] = (1.0 - K / fixE[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixF[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixF[fix_reso] + K * K);\r\n\tfixF[fix_a0] = K * K * norm;\r\n\tfixF[fix_a1] = 2.0 * fixF[fix_a0];\r\n\tfixF[fix_a2] = fixF[fix_a0];\r\n\tfixF[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixF[fix_b2] = (1.0 - K / fixF[fix_reso] + K * K) * norm;\r\n\t\r\n\tdouble inputSampleL = input.left;\r\n\tdouble inputSampleR = input.right;\r\n\tif (fabs(inputSampleL)<1.18e-23) inputSampleL = fpdL * 1.18e-17;\r\n\tif (fabs(inputSampleR)<1.18e-23) inputSampleR = fpdR * 1.18e-17;\r\n\tdouble drySampleL = inputSampleL;\r\n\tdouble drySampleR = inputSampleR;\r\n\r\n\r\n\tdouble outSample = (inputSampleL * fixA[fix_a0]) + fixA[fix_sL1];\r\n\tfixA[fix_sL1] = (inputSampleL * fixA[fix_a1]) - (outSample * fixA[fix_b1]) + fixA[fix_sL2];\r\n\tfixA[fix_sL2] = (inputSampleL * fixA[fix_a2]) - (outSample * fixA[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixA[fix_a0]) + fixA[fix_sR1];\r\n\tfixA[fix_sR1] = (inputSampleR * fixA[fix_a1]) - (outSample * fixA[fix_b1]) + fixA[fix_sR2];\r\n\tfixA[fix_sR2] = (inputSampleR * fixA[fix_a2]) - (outSample * fixA[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tif (inputSampleL > 1.0) inputSampleL = 1.0;\r\n\tif (inputSampleL < -1.0) inputSampleL = -1.0;\r\n\tdouble basscutL = 0.98;\r\n\t//we're going to be shifting this as the stages progress\r\n\tdouble inputlevelL = startlevel;\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleAL = (iirSampleAL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleAL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tdouble bridgerectifier = (smoothAL + inputSampleL);\r\n\tsmoothAL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleBL = (iirSampleBL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleBL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothBL + inputSampleL);\r\n\tsmoothBL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\tif (inputSampleR > 1.0) inputSampleR = 1.0;\r\n\tif (inputSampleR < -1.0) inputSampleR = -1.0;\r\n\tdouble basscutR = 0.98;\r\n\t//we're going to be shifting this as the stages progress\r\n\tdouble inputlevelR = startlevel;\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleAR = (iirSampleAR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleAR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothAR + inputSampleR);\r\n\tsmoothAR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleBR = (iirSampleBR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleBR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothBR + inputSampleR);\r\n\tsmoothBR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\toutSample = (inputSampleL * fixB[fix_a0]) + fixB[fix_sL1];\r\n\tfixB[fix_sL1] = (inputSampleL * fixB[fix_a1]) - (outSample * fixB[fix_b1]) + fixB[fix_sL2];\r\n\tfixB[fix_sL2] = (inputSampleL * fixB[fix_a2]) - (outSample * fixB[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixB[fix_a0]) + fixB[fix_sR1];\r\n\tfixB[fix_sR1] = (inputSampleR * fixB[fix_a1]) - (outSample * fixB[fix_b1]) + fixB[fix_sR2];\r\n\tfixB[fix_sR2] = (inputSampleR * fixB[fix_a2]) - (outSample * fixB[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleCL = (iirSampleCL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleCL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothCL + inputSampleL);\r\n\tsmoothCL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleDL = (iirSampleDL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleDL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothDL + inputSampleL);\r\n\tsmoothDL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleCR = (iirSampleCR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleCR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothCR + inputSampleR);\r\n\tsmoothCR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleDR = (iirSampleDR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleDR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothDR + inputSampleR);\r\n\tsmoothDR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixC[fix_a0]) + fixC[fix_sL1];\r\n\tfixC[fix_sL1] = (inputSampleL * fixC[fix_a1]) - (outSample * fixC[fix_b1]) + fixC[fix_sL2];\r\n\tfixC[fix_sL2] = (inputSampleL * fixC[fix_a2]) - (outSample * fixC[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixC[fix_a0]) + fixC[fix_sR1];\r\n\tfixC[fix_sR1] = (inputSampleR * fixC[fix_a1]) - (outSample * fixC[fix_b1]) + fixC[fix_sR2];\r\n\tfixC[fix_sR2] = (inputSampleR * fixC[fix_a2]) - (outSample * fixC[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleEL = (iirSampleEL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleEL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothEL + inputSampleL);\r\n\tsmoothEL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleFL = (iirSampleFL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleFL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothFL + inputSampleL);\r\n\tsmoothFL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleER = (iirSampleER * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleER*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothER + inputSampleR);\r\n\tsmoothER = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleFR = (iirSampleFR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleFR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothFR + inputSampleR);\r\n\tsmoothFR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixD[fix_a0]) + fixD[fix_sL1];\r\n\tfixD[fix_sL1] = (inputSampleL * fixD[fix_a1]) - (outSample * fixD[fix_b1]) + fixD[fix_sL2];\r\n\tfixD[fix_sL2] = (inputSampleL * fixD[fix_a2]) - (outSample * fixD[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixD[fix_a0]) + fixD[fix_sR1];\r\n\tfixD[fix_sR1] = (inputSampleR * fixD[fix_a1]) - (outSample * fixD[fix_b1]) + fixD[fix_sR2];\r\n\tfixD[fix_sR2] = (inputSampleR * fixD[fix_a2]) - (outSample * fixD[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleGL = (iirSampleGL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleGL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothGL + inputSampleL);\r\n\tsmoothGL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleHL = (iirSampleHL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleHL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothHL + inputSampleL);\r\n\tsmoothHL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleGR = (iirSampleGR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleGR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothGR + inputSampleR);\r\n\tsmoothGR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleHR = (iirSampleHR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleHR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothHR + inputSampleR);\r\n\tsmoothHR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixE[fix_a0]) + fixE[fix_sL1];\r\n\tfixE[fix_sL1] = (inputSampleL * fixE[fix_a1]) - (outSample * fixE[fix_b1]) + fixE[fix_sL2];\r\n\tfixE[fix_sL2] = (inputSampleL * fixE[fix_a2]) - (outSample * fixE[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixE[fix_a0]) + fixE[fix_sR1];\r\n\tfixE[fix_sR1] = (inputSampleR * fixE[fix_a1]) - (outSample * fixE[fix_b1]) + fixE[fix_sR2];\r\n\tfixE[fix_sR2] = (inputSampleR * fixE[fix_a2]) - (outSample * fixE[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleIL = (iirSampleIL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleIL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothIL + inputSampleL);\r\n\tsmoothIL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleJL = (iirSampleJL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleJL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothJL + inputSampleL);\r\n\tsmoothJL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleIR = (iirSampleIR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleIR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothIR + inputSampleR);\r\n\tsmoothIR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleJR = (iirSampleJR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleJR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothJR + inputSampleR);\r\n\tsmoothJR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixF[fix_a0]) + fixF[fix_sL1];\r\n\tfixF[fix_sL1] = (inputSampleL * fixF[fix_a1]) - (outSample * fixF[fix_b1]) + fixF[fix_sL2];\r\n\tfixF[fix_sL2] = (inputSampleL * fixF[fix_a2]) - (outSample * fixF[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixF[fix_a0]) + fixF[fix_sR1];\r\n\tfixF[fix_sR1] = (inputSampleR * fixF[fix_a1]) - (outSample * fixF[fix_b1]) + fixF[fix_sR2];\r\n\tfixF[fix_sR2] = (inputSampleR * fixF[fix_a2]) - (outSample * fixF[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleKL = (iirSampleKL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleKL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothKL + inputSampleL);\r\n\tsmoothKL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleLL = (iirSampleLL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleLL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothLL + inputSampleL);\r\n\tsmoothLL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleKR = (iirSampleKR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleKR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothKR + inputSampleR);\r\n\tsmoothKR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleLR = (iirSampleLR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleLR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothLR + inputSampleR);\r\n\tsmoothLR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\tiirLowpassL = (iirLowpassL * (1.0 - toneEQ)) + (inputSampleL * toneEQ);\r\n\tinputSampleL = iirLowpassL;\r\n\t//lowpass. The only one of this type.\r\n\tiirLowpassR = (iirLowpassR * (1.0 - toneEQ)) + (inputSampleR * toneEQ);\r\n\tinputSampleR = iirLowpassR;\r\n\t//lowpass. The only one of this type.\r\n\r\n\tiirSpkAL = (iirSpkAL * (1.0 -  BEQ)) + (inputSampleL * BEQ);\r\n\t//extra lowpass for 4*12\" speakers\r\n\tiirSpkAR = (iirSpkAR * (1.0 -  BEQ)) + (inputSampleR * BEQ);\r\n\t//extra lowpass for 4*12\" speakers\r\n\r\n\tif (count < 0 || count > 128) {count = 128;}\r\n\tdouble resultBL = 0.0;\r\n\tdouble resultBR = 0.0;\r\n\tif (flip)\r\n\t{\r\n\t\tOddL[count+128] = OddL[count] = iirSpkAL;\r\n\t\tresultBL = (OddL[count+down] + OddL[count+side] + OddL[count+diagonal]);\r\n\t\tOddR[count+128] = OddR[count] = iirSpkAR;\r\n\t\tresultBR = (OddR[count+down] + OddR[count+side] + OddR[count+diagonal]);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEvenL[count+128] = EvenL[count] = iirSpkAL;\r\n\t\tresultBL = (EvenL[count+down] + EvenL[count+side] + EvenL[count+diagonal]);\r\n\t\tEvenR[count+128] = EvenR[count] = iirSpkAR;\r\n\t\tresultBR = (EvenR[count+down] + EvenR[count+side] + EvenR[count+diagonal]);\r\n\t}\r\n\tcount--;\r\n\tiirSpkBL = (iirSpkBL * (1.0 - BEQ)) + (resultBL * BEQ);\r\n\tinputSampleL += (iirSpkBL * bleed);\r\n\t//extra lowpass for 4*12\" speakers\r\n\tiirSpkBR = (iirSpkBR * (1.0 - BEQ)) + (resultBR * BEQ);\r\n\tinputSampleR += (iirSpkBR * bleed);\r\n\t//extra lowpass for 4*12\" speakers\r\n\r\n\tbridgerectifier = fabs(inputSampleL*outputlevel);\r\n\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\tbridgerectifier = sin(bridgerectifier);\r\n\tif (inputSampleL > 0) inputSampleL = bridgerectifier;\r\n\telse inputSampleL = -bridgerectifier;\r\n\r\n\tbridgerectifier = fabs(inputSampleR*outputlevel);\r\n\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\tbridgerectifier = sin(bridgerectifier);\r\n\tif (inputSampleR > 0) inputSampleR = bridgerectifier;\r\n\telse inputSampleR = -bridgerectifier;\r\n\r\n\tiirSubL = (iirSubL * (1.0 - BEQ)) + (inputSampleL * BEQ);\r\n\tinputSampleL += (iirSubL * bassfill * outputlevel);\r\n\r\n\tiirSubR = (iirSubR * (1.0 - BEQ)) + (inputSampleR * BEQ);\r\n\tinputSampleR += (iirSubR * bassfill * outputlevel);\r\n\r\n\tdouble randy = (((double)(fpdL)/0xffffffff)*0.053);\r\n\tinputSampleL = ((inputSampleL*(1.0-randy))+(storeSampleL*randy))*outputlevel;\r\n\tstoreSampleL = inputSampleL;\r\n\r\n\trandy = (((double)(fpdR)/0xffffffff)*0.053);\r\n\tinputSampleR = ((inputSampleR*(1.0-randy))+(storeSampleR*randy))*outputlevel;\r\n\tstoreSampleR = inputSampleR;\r\n\r\n\tflip = flip == 0 ? 1 : 0;\r\n\r\n\t//amp\r\n\r\n\tcycle++;\r\n\tif (cycle == cycleEnd) {\r\n\t\tdouble temp = (inputSampleL + smoothCabAL)/3.0;\r\n\t\tsmoothCabAL = inputSampleL;\r\n\t\tinputSampleL = temp;\r\n\t\t\r\n\t\tbL[84] = bL[83]; bL[83] = bL[82]; bL[82] = bL[81]; bL[81] = bL[80]; bL[80] = bL[79]; \r\n\t\tbL[79] = bL[78]; bL[78] = bL[77]; bL[77] = bL[76]; bL[76] = bL[75]; bL[75] = bL[74]; bL[74] = bL[73]; bL[73] = bL[72]; bL[72] = bL[71]; \r\n\t\tbL[71] = bL[70]; bL[70] = bL[69]; bL[69] = bL[68]; bL[68] = bL[67]; bL[67] = bL[66]; bL[66] = bL[65]; bL[65] = bL[64]; bL[64] = bL[63]; \r\n\t\tbL[63] = bL[62]; bL[62] = bL[61]; bL[61] = bL[60]; bL[60] = bL[59]; bL[59] = bL[58]; bL[58] = bL[57]; bL[57] = bL[56]; bL[56] = bL[55]; \r\n\t\tbL[55] = bL[54]; bL[54] = bL[53]; bL[53] = bL[52]; bL[52] = bL[51]; bL[51] = bL[50]; bL[50] = bL[49]; bL[49] = bL[48]; bL[48] = bL[47]; \r\n\t\tbL[47] = bL[46]; bL[46] = bL[45]; bL[45] = bL[44]; bL[44] = bL[43]; bL[43] = bL[42]; bL[42] = bL[41]; bL[41] = bL[40]; bL[40] = bL[39]; \r\n\t\tbL[39] = bL[38]; bL[38] = bL[37]; bL[37] = bL[36]; bL[36] = bL[35]; bL[35] = bL[34]; bL[34] = bL[33]; bL[33] = bL[32]; bL[32] = bL[31]; \r\n\t\tbL[31] = bL[30]; bL[30] = bL[29]; bL[29] = bL[28]; bL[28] = bL[27]; bL[27] = bL[26]; bL[26] = bL[25]; bL[25] = bL[24]; bL[24] = bL[23]; \r\n\t\tbL[23] = bL[22]; bL[22] = bL[21]; bL[21] = bL[20]; bL[20] = bL[19]; bL[19] = bL[18]; bL[18] = bL[17]; bL[17] = bL[16]; bL[16] = bL[15]; \r\n\t\tbL[15] = bL[14]; bL[14] = bL[13]; bL[13] = bL[12]; bL[12] = bL[11]; bL[11] = bL[10]; bL[10] = bL[9]; bL[9] = bL[8]; bL[8] = bL[7]; \r\n\t\tbL[7] = bL[6]; bL[6] = bL[5]; bL[5] = bL[4]; bL[4] = bL[3]; bL[3] = bL[2]; bL[2] = bL[1]; bL[1] = bL[0]; bL[0] = inputSampleL;\r\n\t\tinputSampleL += (bL[1] * (1.31698250313308396  - (0.08140616497621633*fabs(bL[1]))));\r\n\t\tinputSampleL += (bL[2] * (1.47229016949915326  - (0.27680278993637253*fabs(bL[2]))));\r\n\t\tinputSampleL += (bL[3] * (1.30410109086044956  - (0.35629113432046489*fabs(bL[3]))));\r\n\t\tinputSampleL += (bL[4] * (0.81766210474551260  - (0.26808782337659753*fabs(bL[4]))));\r\n\t\tinputSampleL += (bL[5] * (0.19868872545506663  - (0.11105517193919669*fabs(bL[5]))));\r\n\t\tinputSampleL -= (bL[6] * (0.39115909132567039  - (0.12630622002682679*fabs(bL[6]))));\r\n\t\tinputSampleL -= (bL[7] * (0.76881891559343574  - (0.40879849500403143*fabs(bL[7]))));\r\n\t\tinputSampleL -= (bL[8] * (0.87146861782680340  - (0.59529560488000599*fabs(bL[8]))));\r\n\t\tinputSampleL -= (bL[9] * (0.79504575932563670  - (0.60877047551611796*fabs(bL[9]))));\r\n\t\tinputSampleL -= (bL[10] * (0.61653017622406314  - (0.47662851438557335*fabs(bL[10]))));\r\n\t\tinputSampleL -= (bL[11] * (0.40718195794382067  - (0.24955839378539713*fabs(bL[11]))));\r\n\t\tinputSampleL -= (bL[12] * (0.31794900040616203  - (0.04169792259600613*fabs(bL[12]))));\r\n\t\tinputSampleL -= (bL[13] * (0.41075032540217843  + (0.00368483996076280*fabs(bL[13]))));\r\n\t\tinputSampleL -= (bL[14] * (0.56901352922170667  - (0.11027360805893105*fabs(bL[14]))));\r\n\t\tinputSampleL -= (bL[15] * (0.62443222391889264  - (0.22198075154245228*fabs(bL[15]))));\r\n\t\tinputSampleL -= (bL[16] * (0.53462856723129204  - (0.22933544545324852*fabs(bL[16]))));\r\n\t\tinputSampleL -= (bL[17] * (0.34441703361995046  - (0.12956809502269492*fabs(bL[17]))));\r\n\t\tinputSampleL -= (bL[18] * (0.13947052337867882  + (0.00339775055962799*fabs(bL[18]))));\r\n\t\tinputSampleL += (bL[19] * (0.03771252648928484  - (0.10863931549251718*fabs(bL[19]))));\r\n\t\tinputSampleL += (bL[20] * (0.18280210770271693  - (0.17413646599296417*fabs(bL[20]))));\r\n\t\tinputSampleL += (bL[21] * (0.24621986701761467  - (0.14547053270435095*fabs(bL[21]))));\r\n\t\tinputSampleL += (bL[22] * (0.22347075142737360  - (0.02493869490104031*fabs(bL[22]))));\r\n\t\tinputSampleL += (bL[23] * (0.14346348482123716  + (0.11284054747963246*fabs(bL[23]))));\r\n\t\tinputSampleL += (bL[24] * (0.00834364862916028  + (0.24284684053733926*fabs(bL[24]))));\r\n\t\tinputSampleL -= (bL[25] * (0.11559740296078347  - (0.32623054435304538*fabs(bL[25]))));\r\n\t\tinputSampleL -= (bL[26] * (0.18067604561283060  - (0.32311481551122478*fabs(bL[26]))));\r\n\t\tinputSampleL -= (bL[27] * (0.22927997789035612  - (0.26991539052832925*fabs(bL[27]))));\r\n\t\tinputSampleL -= (bL[28] * (0.28487666578669446  - (0.22437227250279349*fabs(bL[28]))));\r\n\t\tinputSampleL -= (bL[29] * (0.31992973037153838  - (0.15289876100963865*fabs(bL[29]))));\r\n\t\tinputSampleL -= (bL[30] * (0.35174606303520733  - (0.05656293023086628*fabs(bL[30]))));\r\n\t\tinputSampleL -= (bL[31] * (0.36894898011375254  + (0.04333925421463558*fabs(bL[31]))));\r\n\t\tinputSampleL -= (bL[32] * (0.32567576055307507  + (0.14594589410921388*fabs(bL[32]))));\r\n\t\tinputSampleL -= (bL[33] * (0.27440135050585784  + (0.15529667398122521*fabs(bL[33]))));\r\n\t\tinputSampleL -= (bL[34] * (0.21998973785078091  + (0.05083553737157104*fabs(bL[34]))));\r\n\t\tinputSampleL -= (bL[35] * (0.10323624876862457  - (0.04651829594199963*fabs(bL[35]))));\r\n\t\tinputSampleL += (bL[36] * (0.02091603687851074  + (0.12000046818439322*fabs(bL[36]))));\r\n\t\tinputSampleL += (bL[37] * (0.11344930914138468  + (0.17697142512225839*fabs(bL[37]))));\r\n\t\tinputSampleL += (bL[38] * (0.22766779627643968  + (0.13645102964003858*fabs(bL[38]))));\r\n\t\tinputSampleL += (bL[39] * (0.38378309953638229  - (0.01997653307333791*fabs(bL[39]))));\r\n\t\tinputSampleL += (bL[40] * (0.52789400804568076  - (0.21409137428422448*fabs(bL[40]))));\r\n\t\tinputSampleL += (bL[41] * (0.55444630296938280  - (0.32331980931576626*fabs(bL[41]))));\r\n\t\tinputSampleL += (bL[42] * (0.42333237669264601  - (0.26855847463044280*fabs(bL[42]))));\r\n\t\tinputSampleL += (bL[43] * (0.21942831522035078  - (0.12051365248820624*fabs(bL[43]))));\r\n\t\tinputSampleL -= (bL[44] * (0.00584169427830633  - (0.03706970171280329*fabs(bL[44]))));\r\n\t\tinputSampleL -= (bL[45] * (0.24279799124660351  - (0.17296440491477982*fabs(bL[45]))));\r\n\t\tinputSampleL -= (bL[46] * (0.40173760787507085  - (0.21717989835163351*fabs(bL[46]))));\r\n\t\tinputSampleL -= (bL[47] * (0.43930035724188155  - (0.16425928481378199*fabs(bL[47]))));\r\n\t\tinputSampleL -= (bL[48] * (0.41067765934041811  - (0.10390115786636855*fabs(bL[48]))));\r\n\t\tinputSampleL -= (bL[49] * (0.34409235547165967  - (0.07268159377411920*fabs(bL[49]))));\r\n\t\tinputSampleL -= (bL[50] * (0.26542883122568151  - (0.05483457497365785*fabs(bL[50]))));\r\n\t\tinputSampleL -= (bL[51] * (0.22024754776138800  - (0.06484897950087598*fabs(bL[51]))));\r\n\t\tinputSampleL -= (bL[52] * (0.20394367993632415  - (0.08746309731952180*fabs(bL[52]))));\r\n\t\tinputSampleL -= (bL[53] * (0.17565242431124092  - (0.07611309538078760*fabs(bL[53]))));\r\n\t\tinputSampleL -= (bL[54] * (0.10116623231246825  - (0.00642818706295112*fabs(bL[54]))));\r\n\t\tinputSampleL -= (bL[55] * (0.00782648272053632  + (0.08004141267685004*fabs(bL[55]))));\r\n\t\tinputSampleL += (bL[56] * (0.05059046006747323  - (0.12436676387548490*fabs(bL[56]))));\r\n\t\tinputSampleL += (bL[57] * (0.06241531553254467  - (0.11530779547021434*fabs(bL[57]))));\r\n\t\tinputSampleL += (bL[58] * (0.04952694587101836  - (0.08340945324333944*fabs(bL[58]))));\r\n\t\tinputSampleL += (bL[59] * (0.00843873294401687  - (0.03279659052562903*fabs(bL[59]))));\r\n\t\tinputSampleL -= (bL[60] * (0.05161338949440241  - (0.03428181149163798*fabs(bL[60]))));\r\n\t\tinputSampleL -= (bL[61] * (0.08165520146902012  - (0.08196746092283110*fabs(bL[61]))));\r\n\t\tinputSampleL -= (bL[62] * (0.06639532849935320  - (0.09797462781896329*fabs(bL[62]))));\r\n\t\tinputSampleL -= (bL[63] * (0.02953430910661621  - (0.09175612938515763*fabs(bL[63]))));\r\n\t\tinputSampleL += (bL[64] * (0.00741058547442938  + (0.05442091048731967*fabs(bL[64]))));\r\n\t\tinputSampleL += (bL[65] * (0.01832866125391727  + (0.00306243693643687*fabs(bL[65]))));\r\n\t\tinputSampleL += (bL[66] * (0.00526964230373573  - (0.04364102661136410*fabs(bL[66]))));\r\n\t\tinputSampleL -= (bL[67] * (0.00300984373848200  + (0.09742737841278880*fabs(bL[67]))));\r\n\t\tinputSampleL -= (bL[68] * (0.00413616769576694  + (0.14380661694523073*fabs(bL[68]))));\r\n\t\tinputSampleL -= (bL[69] * (0.00588769034931419  + (0.16012843578892538*fabs(bL[69]))));\r\n\t\tinputSampleL -= (bL[70] * (0.00688588239450581  + (0.14074464279305798*fabs(bL[70]))));\r\n\t\tinputSampleL -= (bL[71] * (0.02277307992926315  + (0.07914752191801366*fabs(bL[71]))));\r\n\t\tinputSampleL -= (bL[72] * (0.04627166091180877  - (0.00192787268067208*fabs(bL[72]))));\r\n\t\tinputSampleL -= (bL[73] * (0.05562045897455786  - (0.05932868727665747*fabs(bL[73]))));\r\n\t\tinputSampleL -= (bL[74] * (0.05134243784922165  - (0.08245334798868090*fabs(bL[74]))));\r\n\t\tinputSampleL -= (bL[75] * (0.04719409472239919  - (0.07498680629253825*fabs(bL[75]))));\r\n\t\tinputSampleL -= (bL[76] * (0.05889738914266415  - (0.06116127018043697*fabs(bL[76]))));\r\n\t\tinputSampleL -= (bL[77] * (0.09428363535111127  - (0.06535868867863834*fabs(bL[77]))));\r\n\t\tinputSampleL -= (bL[78] * (0.15181756953225126  - (0.08982979655234427*fabs(bL[78]))));\r\n\t\tinputSampleL -= (bL[79] * (0.20878969456036670  - (0.10761070891499538*fabs(bL[79]))));\r\n\t\tinputSampleL -= (bL[80] * (0.22647885581813790  - (0.08462542510349125*fabs(bL[80]))));\r\n\t\tinputSampleL -= (bL[81] * (0.19723482443646323  - (0.02665160920736287*fabs(bL[81]))));\r\n\t\tinputSampleL -= (bL[82] * (0.16441643451155163  + (0.02314691954338197*fabs(bL[82]))));\r\n\t\tinputSampleL -= (bL[83] * (0.15201914054931515  + (0.04424903493886839*fabs(bL[83]))));\r\n\t\tinputSampleL -= (bL[84] * (0.15454370641307855  + (0.04223203797913008*fabs(bL[84]))));\r\n\t\t\t\t\t\r\n\t\ttemp = (inputSampleL + smoothCabBL)/3.0;\r\n\t\tsmoothCabBL = inputSampleL;\r\n\t\tinputSampleL = temp/4.0;\r\n\t\t\r\n\t\trandy = (((double)(fpdL)/0xffffffff)*0.057);\r\n\t\tdrySampleL = ((inputSampleL*(1-randy))+(lastCabSampleL*randy))*outputlevel;\r\n\t\tlastCabSampleL = inputSampleL;\r\n\t\tinputSampleL = drySampleL; //cab L\r\n\t\t\r\n\t\ttemp = (inputSampleR + smoothCabAR)/3.0;\r\n\t\tsmoothCabAR = inputSampleR;\r\n\t\tinputSampleR = temp;\r\n\t\t\r\n\t\tbR[84] = bR[83]; bR[83] = bR[82]; bR[82] = bR[81]; bR[81] = bR[80]; bR[80] = bR[79]; \r\n\t\tbR[79] = bR[78]; bR[78] = bR[77]; bR[77] = bR[76]; bR[76] = bR[75]; bR[75] = bR[74]; bR[74] = bR[73]; bR[73] = bR[72]; bR[72] = bR[71]; \r\n\t\tbR[71] = bR[70]; bR[70] = bR[69]; bR[69] = bR[68]; bR[68] = bR[67]; bR[67] = bR[66]; bR[66] = bR[65]; bR[65] = bR[64]; bR[64] = bR[63]; \r\n\t\tbR[63] = bR[62]; bR[62] = bR[61]; bR[61] = bR[60]; bR[60] = bR[59]; bR[59] = bR[58]; bR[58] = bR[57]; bR[57] = bR[56]; bR[56] = bR[55]; \r\n\t\tbR[55] = bR[54]; bR[54] = bR[53]; bR[53] = bR[52]; bR[52] = bR[51]; bR[51] = bR[50]; bR[50] = bR[49]; bR[49] = bR[48]; bR[48] = bR[47]; \r\n\t\tbR[47] = bR[46]; bR[46] = bR[45]; bR[45] = bR[44]; bR[44] = bR[43]; bR[43] = bR[42]; bR[42] = bR[41]; bR[41] = bR[40]; bR[40] = bR[39]; \r\n\t\tbR[39] = bR[38]; bR[38] = bR[37]; bR[37] = bR[36]; bR[36] = bR[35]; bR[35] = bR[34]; bR[34] = bR[33]; bR[33] = bR[32]; bR[32] = bR[31]; \r\n\t\tbR[31] = bR[30]; bR[30] = bR[29]; bR[29] = bR[28]; bR[28] = bR[27]; bR[27] = bR[26]; bR[26] = bR[25]; bR[25] = bR[24]; bR[24] = bR[23]; \r\n\t\tbR[23] = bR[22]; bR[22] = bR[21]; bR[21] = bR[20]; bR[20] = bR[19]; bR[19] = bR[18]; bR[18] = bR[17]; bR[17] = bR[16]; bR[16] = bR[15]; \r\n\t\tbR[15] = bR[14]; bR[14] = bR[13]; bR[13] = bR[12]; bR[12] = bR[11]; bR[11] = bR[10]; bR[10] = bR[9]; bR[9] = bR[8]; bR[8] = bR[7]; \r\n\t\tbR[7] = bR[6]; bR[6] = bR[5]; bR[5] = bR[4]; bR[4] = bR[3]; bR[3] = bR[2]; bR[2] = bR[1]; bR[1] = bR[0]; bR[0] = inputSampleR;\r\n\t\tinputSampleR += (bR[1] * (1.31698250313308396  - (0.08140616497621633*fabs(bR[1]))));\r\n\t\tinputSampleR += (bR[2] * (1.47229016949915326  - (0.27680278993637253*fabs(bR[2]))));\r\n\t\tinputSampleR += (bR[3] * (1.30410109086044956  - (0.35629113432046489*fabs(bR[3]))));\r\n\t\tinputSampleR += (bR[4] * (0.81766210474551260  - (0.26808782337659753*fabs(bR[4]))));\r\n\t\tinputSampleR += (bR[5] * (0.19868872545506663  - (0.11105517193919669*fabs(bR[5]))));\r\n\t\tinputSampleR -= (bR[6] * (0.39115909132567039  - (0.12630622002682679*fabs(bR[6]))));\r\n\t\tinputSampleR -= (bR[7] * (0.76881891559343574  - (0.40879849500403143*fabs(bR[7]))));\r\n\t\tinputSampleR -= (bR[8] * (0.87146861782680340  - (0.59529560488000599*fabs(bR[8]))));\r\n\t\tinputSampleR -= (bR[9] * (0.79504575932563670  - (0.60877047551611796*fabs(bR[9]))));\r\n\t\tinputSampleR -= (bR[10] * (0.61653017622406314  - (0.47662851438557335*fabs(bR[10]))));\r\n\t\tinputSampleR -= (bR[11] * (0.40718195794382067  - (0.24955839378539713*fabs(bR[11]))));\r\n\t\tinputSampleR -= (bR[12] * (0.31794900040616203  - (0.04169792259600613*fabs(bR[12]))));\r\n\t\tinputSampleR -= (bR[13] * (0.41075032540217843  + (0.00368483996076280*fabs(bR[13]))));\r\n\t\tinputSampleR -= (bR[14] * (0.56901352922170667  - (0.11027360805893105*fabs(bR[14]))));\r\n\t\tinputSampleR -= (bR[15] * (0.62443222391889264  - (0.22198075154245228*fabs(bR[15]))));\r\n\t\tinputSampleR -= (bR[16] * (0.53462856723129204  - (0.22933544545324852*fabs(bR[16]))));\r\n\t\tinputSampleR -= (bR[17] * (0.34441703361995046  - (0.12956809502269492*fabs(bR[17]))));\r\n\t\tinputSampleR -= (bR[18] * (0.13947052337867882  + (0.00339775055962799*fabs(bR[18]))));\r\n\t\tinputSampleR += (bR[19] * (0.03771252648928484  - (0.10863931549251718*fabs(bR[19]))));\r\n\t\tinputSampleR += (bR[20] * (0.18280210770271693  - (0.17413646599296417*fabs(bR[20]))));\r\n\t\tinputSampleR += (bR[21] * (0.24621986701761467  - (0.14547053270435095*fabs(bR[21]))));\r\n\t\tinputSampleR += (bR[22] * (0.22347075142737360  - (0.02493869490104031*fabs(bR[22]))));\r\n\t\tinputSampleR += (bR[23] * (0.14346348482123716  + (0.11284054747963246*fabs(bR[23]))));\r\n\t\tinputSampleR += (bR[24] * (0.00834364862916028  + (0.24284684053733926*fabs(bR[24]))));\r\n\t\tinputSampleR -= (bR[25] * (0.11559740296078347  - (0.32623054435304538*fabs(bR[25]))));\r\n\t\tinputSampleR -= (bR[26] * (0.18067604561283060  - (0.32311481551122478*fabs(bR[26]))));\r\n\t\tinputSampleR -= (bR[27] * (0.22927997789035612  - (0.26991539052832925*fabs(bR[27]))));\r\n\t\tinputSampleR -= (bR[28] * (0.28487666578669446  - (0.22437227250279349*fabs(bR[28]))));\r\n\t\tinputSampleR -= (bR[29] * (0.31992973037153838  - (0.15289876100963865*fabs(bR[29]))));\r\n\t\tinputSampleR -= (bR[30] * (0.35174606303520733  - (0.05656293023086628*fabs(bR[30]))));\r\n\t\tinputSampleR -= (bR[31] * (0.36894898011375254  + (0.04333925421463558*fabs(bR[31]))));\r\n\t\tinputSampleR -= (bR[32] * (0.32567576055307507  + (0.14594589410921388*fabs(bR[32]))));\r\n\t\tinputSampleR -= (bR[33] * (0.27440135050585784  + (0.15529667398122521*fabs(bR[33]))));\r\n\t\tinputSampleR -= (bR[34] * (0.21998973785078091  + (0.05083553737157104*fabs(bR[34]))));\r\n\t\tinputSampleR -= (bR[35] * (0.10323624876862457  - (0.04651829594199963*fabs(bR[35]))));\r\n\t\tinputSampleR += (bR[36] * (0.02091603687851074  + (0.12000046818439322*fabs(bR[36]))));\r\n\t\tinputSampleR += (bR[37] * (0.11344930914138468  + (0.17697142512225839*fabs(bR[37]))));\r\n\t\tinputSampleR += (bR[38] * (0.22766779627643968  + (0.13645102964003858*fabs(bR[38]))));\r\n\t\tinputSampleR += (bR[39] * (0.38378309953638229  - (0.01997653307333791*fabs(bR[39]))));\r\n\t\tinputSampleR += (bR[40] * (0.52789400804568076  - (0.21409137428422448*fabs(bR[40]))));\r\n\t\tinputSampleR += (bR[41] * (0.55444630296938280  - (0.32331980931576626*fabs(bR[41]))));\r\n\t\tinputSampleR += (bR[42] * (0.42333237669264601  - (0.26855847463044280*fabs(bR[42]))));\r\n\t\tinputSampleR += (bR[43] * (0.21942831522035078  - (0.12051365248820624*fabs(bR[43]))));\r\n\t\tinputSampleR -= (bR[44] * (0.00584169427830633  - (0.03706970171280329*fabs(bR[44]))));\r\n\t\tinputSampleR -= (bR[45] * (0.24279799124660351  - (0.17296440491477982*fabs(bR[45]))));\r\n\t\tinputSampleR -= (bR[46] * (0.40173760787507085  - (0.21717989835163351*fabs(bR[46]))));\r\n\t\tinputSampleR -= (bR[47] * (0.43930035724188155  - (0.16425928481378199*fabs(bR[47]))));\r\n\t\tinputSampleR -= (bR[48] * (0.41067765934041811  - (0.10390115786636855*fabs(bR[48]))));\r\n\t\tinputSampleR -= (bR[49] * (0.34409235547165967  - (0.07268159377411920*fabs(bR[49]))));\r\n\t\tinputSampleR -= (bR[50] * (0.26542883122568151  - (0.05483457497365785*fabs(bR[50]))));\r\n\t\tinputSampleR -= (bR[51] * (0.22024754776138800  - (0.06484897950087598*fabs(bR[51]))));\r\n\t\tinputSampleR -= (bR[52] * (0.20394367993632415  - (0.08746309731952180*fabs(bR[52]))));\r\n\t\tinputSampleR -= (bR[53] * (0.17565242431124092  - (0.07611309538078760*fabs(bR[53]))));\r\n\t\tinputSampleR -= (bR[54] * (0.10116623231246825  - (0.00642818706295112*fabs(bR[54]))));\r\n\t\tinputSampleR -= (bR[55] * (0.00782648272053632  + (0.08004141267685004*fabs(bR[55]))));\r\n\t\tinputSampleR += (bR[56] * (0.05059046006747323  - (0.12436676387548490*fabs(bR[56]))));\r\n\t\tinputSampleR += (bR[57] * (0.06241531553254467  - (0.11530779547021434*fabs(bR[57]))));\r\n\t\tinputSampleR += (bR[58] * (0.04952694587101836  - (0.08340945324333944*fabs(bR[58]))));\r\n\t\tinputSampleR += (bR[59] * (0.00843873294401687  - (0.03279659052562903*fabs(bR[59]))));\r\n\t\tinputSampleR -= (bR[60] * (0.05161338949440241  - (0.03428181149163798*fabs(bR[60]))));\r\n\t\tinputSampleR -= (bR[61] * (0.08165520146902012  - (0.08196746092283110*fabs(bR[61]))));\r\n\t\tinputSampleR -= (bR[62] * (0.06639532849935320  - (0.09797462781896329*fabs(bR[62]))));\r\n\t\tinputSampleR -= (bR[63] * (0.02953430910661621  - (0.09175612938515763*fabs(bR[63]))));\r\n\t\tinputSampleR += (bR[64] * (0.00741058547442938  + (0.05442091048731967*fabs(bR[64]))));\r\n\t\tinputSampleR += (bR[65] * (0.01832866125391727  + (0.00306243693643687*fabs(bR[65]))));\r\n\t\tinputSampleR += (bR[66] * (0.00526964230373573  - (0.04364102661136410*fabs(bR[66]))));\r\n\t\tinputSampleR -= (bR[67] * (0.00300984373848200  + (0.09742737841278880*fabs(bR[67]))));\r\n\t\tinputSampleR -= (bR[68] * (0.00413616769576694  + (0.14380661694523073*fabs(bR[68]))));\r\n\t\tinputSampleR -= (bR[69] * (0.00588769034931419  + (0.16012843578892538*fabs(bR[69]))));\r\n\t\tinputSampleR -= (bR[70] * (0.00688588239450581  + (0.14074464279305798*fabs(bR[70]))));\r\n\t\tinputSampleR -= (bR[71] * (0.02277307992926315  + (0.07914752191801366*fabs(bR[71]))));\r\n\t\tinputSampleR -= (bR[72] * (0.04627166091180877  - (0.00192787268067208*fabs(bR[72]))));\r\n\t\tinputSampleR -= (bR[73] * (0.05562045897455786  - (0.05932868727665747*fabs(bR[73]))));\r\n\t\tinputSampleR -= (bR[74] * (0.05134243784922165  - (0.08245334798868090*fabs(bR[74]))));\r\n\t\tinputSampleR -= (bR[75] * (0.04719409472239919  - (0.07498680629253825*fabs(bR[75]))));\r\n\t\tinputSampleR -= (bR[76] * (0.05889738914266415  - (0.06116127018043697*fabs(bR[76]))));\r\n\t\tinputSampleR -= (bR[77] * (0.09428363535111127  - (0.06535868867863834*fabs(bR[77]))));\r\n\t\tinputSampleR -= (bR[78] * (0.15181756953225126  - (0.08982979655234427*fabs(bR[78]))));\r\n\t\tinputSampleR -= (bR[79] * (0.20878969456036670  - (0.10761070891499538*fabs(bR[79]))));\r\n\t\tinputSampleR -= (bR[80] * (0.22647885581813790  - (0.08462542510349125*fabs(bR[80]))));\r\n\t\tinputSampleR -= (bR[81] * (0.19723482443646323  - (0.02665160920736287*fabs(bR[81]))));\r\n\t\tinputSampleR -= (bR[82] * (0.16441643451155163  + (0.02314691954338197*fabs(bR[82]))));\r\n\t\tinputSampleR -= (bR[83] * (0.15201914054931515  + (0.04424903493886839*fabs(bR[83]))));\r\n\t\tinputSampleR -= (bR[84] * (0.15454370641307855  + (0.04223203797913008*fabs(bR[84]))));\r\n\t\t\r\n\t\ttemp = (inputSampleR + smoothCabBR)/3.0;\r\n\t\tsmoothCabBR = inputSampleR;\r\n\t\tinputSampleR = temp/4.0;\r\n\t\t\r\n\t\trandy = (((double)(fpdR)/0xffffffff)*0.057);\r\n\t\tdrySampleR = ((inputSampleR*(1.0-randy))+(lastCabSampleR*randy))*outputlevel;\r\n\t\tlastCabSampleR = inputSampleR;\r\n\t\tinputSampleR = drySampleR; //cab\r\n\t\t\r\n\t\tif (cycleEnd == 4) {\r\n\t\t\tlastRefL[0] = lastRefL[4]; //start from previous last\r\n\t\t\tlastRefL[2] = (lastRefL[0] + inputSampleL)/2; //half\r\n\t\t\tlastRefL[1] = (lastRefL[0] + lastRefL[2])/2; //one quarter\r\n\t\t\tlastRefL[3] = (lastRefL[2] + inputSampleL)/2; //three quarters\r\n\t\t\tlastRefL[4] = inputSampleL; //full\r\n\t\t\tlastRefR[0] = lastRefR[4]; //start from previous last\r\n\t\t\tlastRefR[2] = (lastRefR[0] + inputSampleR)/2; //half\r\n\t\t\tlastRefR[1] = (lastRefR[0] + lastRefR[2])/2; //one quarter\r\n\t\t\tlastRefR[3] = (lastRefR[2] + inputSampleR)/2; //three quarters\r\n\t\t\tlastRefR[4] = inputSampleR; //full\r\n\t\t}\r\n\t\tif (cycleEnd == 3) {\r\n\t\t\tlastRefL[0] = lastRefL[3]; //start from previous last\r\n\t\t\tlastRefL[2] = (lastRefL[0]+lastRefL[0]+inputSampleL)/3; //third\r\n\t\t\tlastRefL[1] = (lastRefL[0]+inputSampleL+inputSampleL)/3; //two thirds\r\n\t\t\tlastRefL[3] = inputSampleL; //full\r\n\t\t\tlastRefR[0] = lastRefR[3]; //start from previous last\r\n\t\t\tlastRefR[2] = (lastRefR[0]+lastRefR[0]+inputSampleR)/3; //third\r\n\t\t\tlastRefR[1] = (lastRefR[0]+inputSampleR+inputSampleR)/3; //two thirds\r\n\t\t\tlastRefR[3] = inputSampleR; //full\r\n\t\t}\r\n\t\tif (cycleEnd == 2) {\r\n\t\t\tlastRefL[0] = lastRefL[2]; //start from previous last\r\n\t\t\tlastRefL[1] = (lastRefL[0] + inputSampleL)/2; //half\r\n\t\t\tlastRefL[2] = inputSampleL; //full\r\n\t\t\tlastRefR[0] = lastRefR[2]; //start from previous last\r\n\t\t\tlastRefR[1] = (lastRefR[0] + inputSampleR)/2; //half\r\n\t\t\tlastRefR[2] = inputSampleR; //full\r\n\t\t}\r\n\t\tif (cycleEnd == 1) {\r\n\t\t\tlastRefL[0] = inputSampleL;\r\n\t\t\tlastRefR[0] = inputSampleR;\r\n\t\t}\r\n\t\tcycle = 0; //reset\r\n\t\tinputSampleL = lastRefL[cycle];\r\n\t\tinputSampleR = lastRefR[cycle];\r\n\t} else {\r\n\t\tinputSampleL = lastRefL[cycle];\r\n\t\tinputSampleR = lastRefR[cycle];\r\n\t\t//we are going through our references now\r\n\t}\r\n\tswitch (cycleEnd) //multi-pole average using lastRef[] variables\r\n\t{\r\n\t\tcase 4:\r\n\t\t\tlastRefL[8] = inputSampleL; inputSampleL = (inputSampleL+lastRefL[7])*0.5;\r\n\t\t\tlastRefL[7] = lastRefL[8]; //continue, do not break\r\n\t\t\tlastRefR[8] = inputSampleR; inputSampleR = (inputSampleR+lastRefR[7])*0.5;\r\n\t\t\tlastRefR[7] = lastRefR[8]; //continue, do not break\r\n\t\tcase 3:\r\n\t\t\tlastRefL[8] = inputSampleL; inputSampleL = (inputSampleL+lastRefL[6])*0.5;\r\n\t\t\tlastRefL[6] = lastRefL[8]; //continue, do not break\r\n\t\t\tlastRefR[8] = inputSampleR; inputSampleR = (inputSampleR+lastRefR[6])*0.5;\r\n\t\t\tlastRefR[6] = lastRefR[8]; //continue, do not break\r\n\t\tcase 2:\r\n\t\t\tlastRefL[8] = inputSampleL; inputSampleL = (inputSampleL+lastRefL[5])*0.5;\r\n\t\t\tlastRefL[5] = lastRefL[8]; //continue, do not break\r\n\t\t\tlastRefR[8] = inputSampleR; inputSampleR = (inputSampleR+lastRefR[5])*0.5;\r\n\t\t\tlastRefR[5] = lastRefR[8]; //continue, do not break\r\n\t\tcase 1:\r\n\t\t\tbreak; //no further averaging\r\n\t}\r\n\r\n\t//begin 32 bit stereo floating point dither\r\n\tint expon; frexpf((float)inputSampleL, &expon);\r\n\tfpdL ^= fpdL << 13; fpdL ^= fpdL >> 17; fpdL ^= fpdL << 5;\r\n\tinputSampleL += (((double)(fpdL)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\tfrexpf((float)inputSampleR, &expon);\r\n\tfpdR ^= fpdR << 13; fpdR ^= fpdR >> 17; fpdR ^= fpdR << 5;\r\n\tinputSampleR += (((double)(fpdR)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\t//end 32 bit stereo floating point dither\r\n\r\n\tStereo output;\r\n\toutput.left = inputSampleL;\r\n\toutput.right = inputSampleR;\r\n\t\r\n\treturn output;\r\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"...","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"FireAmp (Airwindows)","KnobDefaultValue9":"0.500000","CompilationId":"ff0429ee-9d68-46dc-98de-b2962c0db70e","SwitchName1":"","SwitchDefaultValue0":"0","SwitchName0":"","SwitchDefaultValue1":"0","Description":"A bright, loud, tubey amp sim for leads and dirt guitar.","Created":"2022-Jun-24 23:52:41","LastModified":"2022-Jun-24 23:52:59","SwitchDefaultValue2":"0","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":""},"To Tape 5 (Airwindows)":{"KnobName1":"Softer","KnobDefaultValue0":"0.250000","KnobName0":"Louder","KnobDefaultValue1":"0.000000","KnobName3":"Flutter","KnobDefaultValue2":"0.000000","KnobName2":"Fatter","Source":"/* ========================================\r\n *  ToTape5 - ToTape5.h\r\n *  Copyright (c) 2016 airwindows, All rights reserved\r\n * ======================================== */\r\n\r\nint gcount = 0;\r\ndouble rateof = 0.5;\r\ndouble sweep = 0;\r\ndouble nextmax = 0.5;\r\nint hcount = 0;\r\nint flip = 0;\r\n\r\ndouble dL[1000] = {0};\r\ndouble eL[1000] = {0};\r\ndouble dR[1000] = {0};\r\ndouble eR[1000] = {0};\r\n\r\ndouble iirMidRollerAL = 0;\r\ndouble iirMidRollerBL = 0;\r\ndouble iirMidRollerCL = 0;\r\ndouble iirHeadBumpAL = 0;\r\ndouble iirHeadBumpBL = 0;\r\ndouble iirHeadBumpCL = 0;\r\ndouble iirMinHeadBumpL = 0;\r\n\r\ndouble iirMidRollerAR = 0;\r\ndouble iirMidRollerBR = 0;\r\ndouble iirMidRollerCR = 0;\r\ndouble iirHeadBumpAR = 0;\r\ndouble iirHeadBumpBR = 0;\r\ndouble iirHeadBumpCR = 0;\r\ndouble iirMinHeadBumpR = 0;\r\n\r\ndouble iirSampleAL = 0;\r\ndouble iirSampleBL = 0;\r\ndouble iirSampleCL = 0;\r\ndouble iirSampleDL = 0;\r\ndouble iirSampleEL = 0;\r\ndouble iirSampleFL = 0;\r\ndouble iirSampleGL = 0;\r\ndouble iirSampleHL = 0;\r\ndouble iirSampleIL = 0;\r\ndouble iirSampleJL = 0;\r\ndouble iirSampleKL = 0;\r\ndouble iirSampleLL = 0;\r\ndouble iirSampleML = 0;\r\ndouble iirSampleNL = 0;\r\ndouble iirSampleOL = 0;\r\ndouble iirSamplePL = 0;\r\ndouble iirSampleQL = 0;\r\ndouble iirSampleRL = 0;\r\ndouble iirSampleSL = 0;\r\ndouble iirSampleTL = 0;\r\ndouble iirSampleUL = 0;\r\ndouble iirSampleVL = 0;\r\ndouble iirSampleWL = 0;\r\ndouble iirSampleXL = 0;\r\ndouble iirSampleYL = 0;\r\ndouble iirSampleZL = 0;\r\n\r\ndouble iirSampleAR = 0;\r\ndouble iirSampleBR = 0;\r\ndouble iirSampleCR = 0;\r\ndouble iirSampleDR = 0;\r\ndouble iirSampleER = 0;\r\ndouble iirSampleFR = 0;\r\ndouble iirSampleGR = 0;\r\ndouble iirSampleHR = 0;\r\ndouble iirSampleIR = 0;\r\ndouble iirSampleJR = 0;\r\ndouble iirSampleKR = 0;\r\ndouble iirSampleLR = 0;\r\ndouble iirSampleMR = 0;\r\ndouble iirSampleNR = 0;\r\ndouble iirSampleOR = 0;\r\ndouble iirSamplePR = 0;\r\ndouble iirSampleQR = 0;\r\ndouble iirSampleRR = 0;\r\ndouble iirSampleSR = 0;\r\ndouble iirSampleTR = 0;\r\ndouble iirSampleUR = 0;\r\ndouble iirSampleVR = 0;\r\ndouble iirSampleWR = 0;\r\ndouble iirSampleXR = 0;\r\ndouble iirSampleYR = 0;\r\ndouble iirSampleZR = 0;\r\n\r\n\r\nuint32_t fpdL = 0xdeadbeef;\r\nuint32_t fpdR = 0xcafebabe;\r\n\r\nformula_main_stereo {\r\n\tdouble overallscale = 1.0;\r\n\toverallscale /= 44100.0;\r\n\toverallscale *= SAMPLE_RATE;\r\n\tdouble fpOld = 0.618033988749894848204586; //golden ratio!\r\n\tdouble inputgain = pow(KNOB_1+1.0,3);\r\n\tdouble outputgain = KNOB_5;\r\n\t\r\n\tdouble trim = 0.211324865405187117745425;\r\n\tdouble SoftenControl = pow(KNOB_2,2);\r\n\tdouble tempRandy = 0.06 + (SoftenControl/10.0);\r\n\tdouble RollAmount = (1.0-(SoftenControl * 0.45))/overallscale;\r\n\tdouble HeadBumpControl = pow(KNOB_3,2);\r\n\tint allpasstemp;\r\n\tint maxdelay = (int)(floor(((HeadBumpControl+0.3)*2.2)*overallscale));\r\n\tHeadBumpControl *= fabs(HeadBumpControl);\r\n\tdouble HeadBumpFreq = 0.044/overallscale;\r\n\tdouble iirAmount = 0.000001/overallscale;\r\n\tdouble altAmount = 1.0 - iirAmount;\r\n\tdouble iirHBoostAmount = 0.0001/overallscale;\r\n\tdouble altHBoostAmount = 1.0 - iirAmount;\r\n\tdouble depth = pow(KNOB_4,2)*overallscale;\r\n\tdouble fluttertrim = 0.005/overallscale;\r\n\tdouble sweeptrim = (0.0006*depth)/overallscale;\r\n\tdouble offset;\t\r\n\tdouble tupi = 3.141592653589793238 * 2.0;\r\n\tdouble newrate = 0.005/overallscale;\r\n\tdouble oldrate = 1.0-newrate;\r\n\tdouble flutterrandy;\r\n\tdouble randy;\r\n\tdouble invrandy;\r\n\tint count;\r\n\t\r\n\tdouble HighsSampleL = 0.0;\r\n\tdouble NonHighsSampleL = 0.0;\r\n\tdouble HeadBumpL = 0.0;\r\n\tdouble SubtractL;\r\n\tdouble bridgerectifierL;\r\n\tdouble tempSampleL;\r\n\tdouble drySampleL;\r\n\r\n\tdouble HighsSampleR = 0.0;\r\n\tdouble NonHighsSampleR = 0.0;\r\n\tdouble HeadBumpR = 0.0;\r\n\tdouble SubtractR;\r\n\tdouble bridgerectifierR;\r\n\tdouble tempSampleR;\r\n\tdouble drySampleR;\r\n\t\r\n\tdouble inputSampleL = input.left;\r\n\tdouble inputSampleR = input.right;\r\n\t\r\n\tif (fabs(inputSampleL)<1.18e-23) inputSampleL = fpdL * 1.18e-17;\r\n\tif (fabs(inputSampleR)<1.18e-23) inputSampleR = fpdR * 1.18e-17;\r\n\tdrySampleL = inputSampleL;\r\n\tdrySampleR = inputSampleR;\r\n\t\r\n\t\r\n\tflutterrandy = ((double)(fpdL)/0xffffffff);\r\n\trandy = flutterrandy * tempRandy; //for soften\r\n\tinvrandy = (1.0-randy);\r\n\trandy /= 2.0;\r\n\t//we've set up so that we dial in the amount of the alt sections (in pairs) with invrandy being the source section\r\n\t\r\n\t//now we've got a random flutter, so we're messing with the pitch before tape effects go on\r\n\tif (gcount < 0 || gcount > 300) {gcount = 300;}\r\n\tcount = gcount;\r\n\tdL[count+301] = dL[count] = inputSampleL;\r\n\tdR[count+301] = dR[count] = inputSampleR;\r\n\tgcount--;\r\n\t//we will also keep the buffer going, even when not in use\r\n\t\r\n\tif (depth != 0.0) {\r\n\t\toffset = (1.0 + sin(sweep)) * depth;\r\n\t\tcount += (int)floor(offset);\r\n\t\t\r\n\t\tbridgerectifierL = (dL[count] * (1-(offset-floor(offset))));\r\n\t\tbridgerectifierL += (dL[count+1] * (offset-floor(offset)));\r\n\t\tbridgerectifierL -= ((dL[count+2] * (offset-floor(offset)))*trim);\r\n\t\t\r\n\t\tbridgerectifierR = (dR[count] * (1-(offset-floor(offset))));\r\n\t\tbridgerectifierR += (dR[count+1] * (offset-floor(offset)));\r\n\t\tbridgerectifierR -= ((dR[count+2] * (offset-floor(offset)))*trim);\r\n\t\t\r\n\t\trateof = (nextmax * newrate) + (rateof * oldrate);\r\n\t\tsweep += rateof * fluttertrim;\r\n\t\tsweep += sweep * sweeptrim;\r\n\t\tif (sweep >= tupi){sweep = 0.0; nextmax = 0.02 + (flutterrandy*0.98);}\r\n\t\tinputSampleL = bridgerectifierL;\r\n\t\tinputSampleR = bridgerectifierR;\r\n\t\t//apply to input signal only when flutter is present, interpolate samples\r\n\t}\r\n\t\r\n\tif (inputgain != 1.0) {\r\n\t\tinputSampleL *= inputgain;\r\n\t\tinputSampleR *= inputgain;\r\n\t}\r\n\t\r\n\tif (flip < 1 || flip > 3) flip = 1;\r\n\tswitch (flip)\r\n\t{\r\n\t\tcase 1:\t\t\t\t\r\n\t\t\tiirMidRollerAL = (iirMidRollerAL * (1.0 - RollAmount)) + (inputSampleL * RollAmount);\r\n\t\t\tiirMidRollerAL = (invrandy * iirMidRollerAL) + (randy * iirMidRollerBL) + (randy * iirMidRollerCL);\r\n\t\t\tHighsSampleL = inputSampleL - iirMidRollerAL;\r\n\t\t\tNonHighsSampleL = iirMidRollerAL;\r\n\t\t\t\r\n\t\t\tiirHeadBumpAL += (inputSampleL * 0.05);\r\n\t\t\tiirHeadBumpAL -= (iirHeadBumpAL * iirHeadBumpAL * iirHeadBumpAL * HeadBumpFreq);\r\n\t\t\tiirHeadBumpAL = (invrandy * iirHeadBumpAL) + (randy * iirHeadBumpBL) + (randy * iirHeadBumpCL);\r\n\r\n\t\t\tiirMidRollerAR = (iirMidRollerAR * (1.0 - RollAmount)) + (inputSampleR * RollAmount);\r\n\t\t\tiirMidRollerAR = (invrandy * iirMidRollerAR) + (randy * iirMidRollerBR) + (randy * iirMidRollerCR);\r\n\t\t\tHighsSampleR = inputSampleR - iirMidRollerAR;\r\n\t\t\tNonHighsSampleR = iirMidRollerAR;\r\n\t\t\t\r\n\t\t\tiirHeadBumpAR += (inputSampleR * 0.05);\r\n\t\t\tiirHeadBumpAR -= (iirHeadBumpAR * iirHeadBumpAR * iirHeadBumpAR * HeadBumpFreq);\r\n\t\t\tiirHeadBumpAR = (invrandy * iirHeadBumpAR) + (randy * iirHeadBumpBR) + (randy * iirHeadBumpCR);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tiirMidRollerBL = (iirMidRollerBL * (1.0 - RollAmount)) + (inputSampleL * RollAmount);\r\n\t\t\tiirMidRollerBL = (randy * iirMidRollerAL) + (invrandy * iirMidRollerBL) + (randy * iirMidRollerCL);\r\n\t\t\tHighsSampleL = inputSampleL - iirMidRollerBL;\r\n\t\t\tNonHighsSampleL = iirMidRollerBL;\r\n\t\t\t\r\n\t\t\tiirHeadBumpBL += (inputSampleL * 0.05);\r\n\t\t\tiirHeadBumpBL -= (iirHeadBumpBL * iirHeadBumpBL * iirHeadBumpBL * HeadBumpFreq);\r\n\t\t\tiirHeadBumpBL = (randy * iirHeadBumpAL) + (invrandy * iirHeadBumpBL) + (randy * iirHeadBumpCL);\r\n\r\n\t\t\tiirMidRollerBR = (iirMidRollerBR * (1.0 - RollAmount)) + (inputSampleR * RollAmount);\r\n\t\t\tiirMidRollerBR = (randy * iirMidRollerAR) + (invrandy * iirMidRollerBR) + (randy * iirMidRollerCR);\r\n\t\t\tHighsSampleR = inputSampleR - iirMidRollerBR;\r\n\t\t\tNonHighsSampleR = iirMidRollerBR;\r\n\t\t\t\r\n\t\t\tiirHeadBumpBR += (inputSampleR * 0.05);\r\n\t\t\tiirHeadBumpBR -= (iirHeadBumpBR * iirHeadBumpBR * iirHeadBumpBR * HeadBumpFreq);\r\n\t\t\tiirHeadBumpBR = (randy * iirHeadBumpAR) + (invrandy * iirHeadBumpBR) + (randy * iirHeadBumpCR);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tiirMidRollerCL = (iirMidRollerCL * (1.0 - RollAmount)) + (inputSampleL * RollAmount);\r\n\t\t\tiirMidRollerCL = (randy * iirMidRollerAL) + (randy * iirMidRollerBL) + (invrandy * iirMidRollerCL);\r\n\t\t\tHighsSampleL = inputSampleL - iirMidRollerCL;\r\n\t\t\tNonHighsSampleL = iirMidRollerCL;\r\n\t\t\t\r\n\t\t\tiirHeadBumpCL += (inputSampleL * 0.05);\r\n\t\t\tiirHeadBumpCL -= (iirHeadBumpCL * iirHeadBumpCL * iirHeadBumpCL * HeadBumpFreq);\r\n\t\t\tiirHeadBumpCL = (randy * iirHeadBumpAL) + (randy * iirHeadBumpBL) + (invrandy * iirHeadBumpCL);\r\n\r\n\t\t\tiirMidRollerCR = (iirMidRollerCR * (1.0 - RollAmount)) + (inputSampleR * RollAmount);\r\n\t\t\tiirMidRollerCR = (randy * iirMidRollerAR) + (randy * iirMidRollerBR) + (invrandy * iirMidRollerCR);\r\n\t\t\tHighsSampleR = inputSampleR - iirMidRollerCR;\r\n\t\t\tNonHighsSampleR = iirMidRollerCR;\r\n\t\t\t\r\n\t\t\tiirHeadBumpCR += (inputSampleR * 0.05);\r\n\t\t\tiirHeadBumpCR -= (iirHeadBumpCR * iirHeadBumpCR * iirHeadBumpCR * HeadBumpFreq);\r\n\t\t\tiirHeadBumpCR = (randy * iirHeadBumpAR) + (randy * iirHeadBumpBR) + (invrandy * iirHeadBumpCR);\r\n\t\t\tbreak;\r\n\t}\r\n\tflip++; //increment the triplet counter\r\n\t\t\r\n\tSubtractL = HighsSampleL;\t\t\r\n\tbridgerectifierL = fabs(SubtractL)*1.57079633;\r\n\tif (bridgerectifierL > 1.57079633) bridgerectifierL = 1.57079633;\r\n\tbridgerectifierL = 1-cos(bridgerectifierL);\r\n\tif (SubtractL > 0) SubtractL = bridgerectifierL;\r\n\tif (SubtractL < 0) SubtractL = -bridgerectifierL;\r\n\tinputSampleL -= SubtractL;\r\n\r\n\tSubtractR = HighsSampleR;\t\t\r\n\tbridgerectifierR = fabs(SubtractR)*1.57079633;\r\n\tif (bridgerectifierR > 1.57079633) bridgerectifierR = 1.57079633;\r\n\tbridgerectifierR = 1-cos(bridgerectifierR);\r\n\tif (SubtractR > 0) SubtractR = bridgerectifierR;\r\n\tif (SubtractR < 0) SubtractR = -bridgerectifierR;\r\n\tinputSampleR -= SubtractR;\r\n\t//Soften works using the MidRoller stuff, defining a bright parallel channel that we apply negative Density\r\n\t//to, and then subtract from the main audio. That makes the 'highs channel subtract' hit only the loudest\r\n\t//transients, plus we are subtracting any artifacts we got from the negative Density.\t\t\r\n\t\r\n\tbridgerectifierL = fabs(inputSampleL);\r\n\tif (bridgerectifierL > 1.57079633) bridgerectifierL = 1.57079633;\r\n\tbridgerectifierL = sin(bridgerectifierL);\r\n\tif (inputSampleL > 0) inputSampleL = bridgerectifierL;\r\n\tif (inputSampleL < 0) inputSampleL = -bridgerectifierL;\r\n\r\n\tbridgerectifierR = fabs(inputSampleR);\r\n\tif (bridgerectifierR > 1.57079633) bridgerectifierR = 1.57079633;\r\n\tbridgerectifierR = sin(bridgerectifierR);\r\n\tif (inputSampleR > 0) inputSampleR = bridgerectifierR;\r\n\tif (inputSampleR < 0) inputSampleR = -bridgerectifierR;\r\n\t//drive section: the tape sound includes a very gentle saturation curve, which is always an attenuation.\r\n\t//we cut back on highs before hitting this, and then we're going to subtract highs a second time after.\r\n\t\r\n\tHeadBumpL = iirHeadBumpAL + iirHeadBumpBL + iirHeadBumpCL;\r\n\tHeadBumpR = iirHeadBumpAR + iirHeadBumpBR + iirHeadBumpCR;\r\n\t//begin PhaseNudge\r\n\tallpasstemp = hcount - 1;\r\n\tif (allpasstemp < 0 || allpasstemp > maxdelay) {allpasstemp = maxdelay;}\r\n\t\r\n\tHeadBumpL -= eL[allpasstemp] * fpOld;\r\n\teL[hcount] = HeadBumpL;\r\n\tinputSampleL *= fpOld;\r\n\t\r\n\tHeadBumpR -= eR[allpasstemp] * fpOld;\r\n\teR[hcount] = HeadBumpR;\r\n\tinputSampleR *= fpOld;\r\n\t\r\n\thcount--; if (hcount < 0 || hcount > maxdelay) {hcount = maxdelay;}\r\n\tHeadBumpL += (eL[hcount]);\r\n\tHeadBumpR += (eR[hcount]);\r\n\t//end PhaseNudge on head bump in lieu of delay. \r\n\tSubtractL -= (HeadBumpL * (HeadBumpControl+iirMinHeadBumpL));\r\n\tSubtractR -= (HeadBumpR * (HeadBumpControl+iirMinHeadBumpR));\r\n\t//makes a second soften and a single head bump after saturation.\r\n\t//we are going to retain this, and then feed it into the highpass filter. That way, we can skip a subtract.\r\n\t//Head Bump retains a trace which is roughly as large as what the highpass will do.\r\n\t\r\n\ttempSampleL = inputSampleL;\r\n\ttempSampleR = inputSampleR;\r\n\t\r\n\tiirMinHeadBumpL = (iirMinHeadBumpL * altHBoostAmount) + (fabs(inputSampleL) * iirHBoostAmount);\r\n\tif (iirMinHeadBumpL > 0.01) iirMinHeadBumpL = 0.01;\r\n\r\n\tiirMinHeadBumpR = (iirMinHeadBumpR * altHBoostAmount) + (fabs(inputSampleR) * iirHBoostAmount);\r\n\tif (iirMinHeadBumpR > 0.01) iirMinHeadBumpR = 0.01;\r\n\t//we want this one rectified so that it's a relatively steady positive value. Boosts can cause it to be\r\n\t//greater than 1 so we clamp it in that case.\r\n\t\r\n\tiirSampleAL = (iirSampleAL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleAL; SubtractL += iirSampleAL;\r\n\tiirSampleBL = (iirSampleBL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleBL; SubtractL += iirSampleBL;\r\n\tiirSampleCL = (iirSampleCL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleCL; SubtractL += iirSampleCL;\r\n\tiirSampleDL = (iirSampleDL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleDL; SubtractL += iirSampleDL;\r\n\tiirSampleEL = (iirSampleEL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleEL; SubtractL += iirSampleEL;\r\n\tiirSampleFL = (iirSampleFL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleFL; SubtractL += iirSampleFL;\r\n\tiirSampleGL = (iirSampleGL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleGL; SubtractL += iirSampleGL;\r\n\tiirSampleHL = (iirSampleHL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleHL; SubtractL += iirSampleHL;\r\n\tiirSampleIL = (iirSampleIL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleIL; SubtractL += iirSampleIL;\r\n\tiirSampleJL = (iirSampleJL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleJL; SubtractL += iirSampleJL;\r\n\tiirSampleKL = (iirSampleKL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleKL; SubtractL += iirSampleKL;\r\n\tiirSampleLL = (iirSampleLL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleLL; SubtractL += iirSampleLL;\r\n\tiirSampleML = (iirSampleML * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleML; SubtractL += iirSampleML;\r\n\tiirSampleNL = (iirSampleNL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleNL; SubtractL += iirSampleNL;\r\n\tiirSampleOL = (iirSampleOL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleOL; SubtractL += iirSampleOL;\r\n\tiirSamplePL = (iirSamplePL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSamplePL; SubtractL += iirSamplePL;\r\n\tiirSampleQL = (iirSampleQL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleQL; SubtractL += iirSampleQL;\r\n\tiirSampleRL = (iirSampleRL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleRL; SubtractL += iirSampleRL;\r\n\tiirSampleSL = (iirSampleSL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleSL; SubtractL += iirSampleSL;\r\n\tiirSampleTL = (iirSampleTL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleTL; SubtractL += iirSampleTL;\r\n\tiirSampleUL = (iirSampleUL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleUL; SubtractL += iirSampleUL;\r\n\tiirSampleVL = (iirSampleVL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleVL; SubtractL += iirSampleVL;\r\n\tiirSampleWL = (iirSampleWL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleWL; SubtractL += iirSampleWL;\r\n\tiirSampleXL = (iirSampleXL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleXL; SubtractL += iirSampleXL;\r\n\tiirSampleYL = (iirSampleYL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleYL; SubtractL += iirSampleYL;\r\n\tiirSampleZL = (iirSampleZL * altAmount) + (tempSampleL * iirAmount); tempSampleL -= iirSampleZL; SubtractL += iirSampleZL;\r\n\r\n\tiirSampleAR = (iirSampleAR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleAR; SubtractR += iirSampleAR;\r\n\tiirSampleBR = (iirSampleBR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleBR; SubtractR += iirSampleBR;\r\n\tiirSampleCR = (iirSampleCR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleCR; SubtractR += iirSampleCR;\r\n\tiirSampleDR = (iirSampleDR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleDR; SubtractR += iirSampleDR;\r\n\tiirSampleER = (iirSampleER * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleER; SubtractR += iirSampleER;\r\n\tiirSampleFR = (iirSampleFR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleFR; SubtractR += iirSampleFR;\r\n\tiirSampleGR = (iirSampleGR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleGR; SubtractR += iirSampleGR;\r\n\tiirSampleHR = (iirSampleHR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleHR; SubtractR += iirSampleHR;\r\n\tiirSampleIR = (iirSampleIR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleIR; SubtractR += iirSampleIR;\r\n\tiirSampleJR = (iirSampleJR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleJR; SubtractR += iirSampleJR;\r\n\tiirSampleKR = (iirSampleKR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleKR; SubtractR += iirSampleKR;\r\n\tiirSampleLR = (iirSampleLR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleLR; SubtractR += iirSampleLR;\r\n\tiirSampleMR = (iirSampleMR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleMR; SubtractR += iirSampleMR;\r\n\tiirSampleNR = (iirSampleNR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleNR; SubtractR += iirSampleNR;\r\n\tiirSampleOR = (iirSampleOR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleOR; SubtractR += iirSampleOR;\r\n\tiirSamplePR = (iirSamplePR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSamplePR; SubtractR += iirSamplePR;\r\n\tiirSampleQR = (iirSampleQR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleQR; SubtractR += iirSampleQR;\r\n\tiirSampleRR = (iirSampleRR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleRR; SubtractR += iirSampleRR;\r\n\tiirSampleSR = (iirSampleSR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleSR; SubtractR += iirSampleSR;\r\n\tiirSampleTR = (iirSampleTR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleTR; SubtractR += iirSampleTR;\r\n\tiirSampleUR = (iirSampleUR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleUR; SubtractR += iirSampleUR;\r\n\tiirSampleVR = (iirSampleVR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleVR; SubtractR += iirSampleVR;\r\n\tiirSampleWR = (iirSampleWR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleWR; SubtractR += iirSampleWR;\r\n\tiirSampleXR = (iirSampleXR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleXR; SubtractR += iirSampleXR;\r\n\tiirSampleYR = (iirSampleYR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleYR; SubtractR += iirSampleYR;\r\n\tiirSampleZR = (iirSampleZR * altAmount) + (tempSampleR * iirAmount); tempSampleR -= iirSampleZR; SubtractR += iirSampleZR;\r\n\t//do the IIR on a dummy sample, and store up the correction in a variable at the same scale as the very low level\r\n\t//numbers being used. Don't keep doing it against the possibly high level signal number.\r\n\t//This has been known to add a resonant quality to the cutoff, which we're using on purpose.\r\n\t\r\n\tinputSampleL -= SubtractL;\r\n\tinputSampleR -= SubtractR;\r\n\t//apply stored up tiny corrections.\r\n\t\r\n\t//begin 32 bit stereo floating point dither\r\n\tint expon; frexpf((float)inputSampleL, &expon);\r\n\tfpdL ^= fpdL << 13; fpdL ^= fpdL >> 17; fpdL ^= fpdL << 5;\r\n\tinputSampleL += (((double)(fpdL)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\tfrexpf((float)inputSampleR, &expon);\r\n\tfpdR ^= fpdR << 13; fpdR ^= fpdR >> 17; fpdR ^= fpdR << 5;\r\n\tinputSampleR += (((double)(fpdR)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\t//end 32 bit stereo floating point dither\r\n\r\n\tStereo output;\r\n\toutput.left = inputSampleL;\r\n\toutput.right = inputSampleR;\r\n\treturn output;\r\n}","KnobDefaultValue3":"0.000000","KnobName5":"...","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"1.000000","KnobName4":"...","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"1.000000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"To Tape 5 (Airwindows)","KnobDefaultValue9":"0.500000","CompilationId":"bd7ef51f-26fd-4edc-828c-1be4618672ea","SwitchDefaultValue0":"0","SwitchName1":"","SwitchDefaultValue1":"0","SwitchName0":"","Description":"The highest quality Airwindows analog tape emulation.","Created":"2022-Jul-01 10:44:31","LastModified":"2022-Jul-01 10:44:31","SwitchDefaultValue2":"0","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":"","DummyProperty":"expetitur"}}