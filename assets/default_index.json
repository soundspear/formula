{"Tutorial 1: Your first effect":{"KnobName1":"","KnobDefaultValue0":"0.500000","KnobName0":"","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 1: Your first effect\r\n\r\n    Welcome to Formula!\r\n    In this tutorial you will learn the structure\r\n    of a basic effect: we will create a simple gain booster.\r\n    \r\n    NOTE: Formulas are made using the C programming language, we advise you to learn the most\r\n    basic features of that language (variables, operations, conditions).\r\n\r\n    An audio signal is made of a sequence of samples.\r\n    \r\n    All the code you put between 'formula_main {' and '}' will be executed for each sample.\r\n    \r\n    You want to process each input sample and return it as a modified output sample.\r\n    \r\n    Inside formula_main, you can access your input sample as the float variable 'input'.\r\n    Here, we multiply the input sample by 2, hence doubling the gain of our input.\r\n    \r\n    The result is stored in a new variable 'boostedInput', and we use the \r\n    'return' keyword to return this variable as our modified output.\r\n*/\r\n\nformula_main {\n    float boostedInput = input * 2;\r\n    \n    return boostedInput;\n}\r\n\r\n/* Try changing the gain value, hit the play button in Formula and play a sound in your track! */","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 1: Your first effect","KnobDefaultValue9":"0.500000","CompilationId":"fe3ebea6-0b18-4e69-bd69-81a020b23972","Description":"You will learn the structure of a basic effect: we will create a simple gain booster.","Created":"2022-May-29 11:53:42","LastModified":"2022-May-29 18:10:24","SwitchName1":"","SwitchDefaultValue0":"","SwitchDefaultValue1":"","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 2: Using controls":{"KnobName1":"","KnobDefaultValue0":"0.500000","KnobName0":"Gain","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 2: Using controls\r\n\r\n    In this tutorial you will learn to make your effect react to the controls in the knobs panel.\r\n    \r\n    You can open the knob panel by clicking the blue button in the bottom of the side bar.\r\n    Knobs labels can be customized and the knobs labels and values will be saved along with your formula.\r\n\r\n    In your formula, you can access the 12 different knobs using the values KNOB_1, KNOB_2, ..., KNOB_12.\r\n    The knobs will always have a value between 0 (0%) and 1 (100%).\r\n    \r\n    You can also access the 3 switches using SWITCH_1, SWITCH2 and SWITCH_3.\r\n    The value of a switch will be either 0 (off) or 1 (on).\r\n    \r\n    Here, we will use the first switch to determine if we want to do a gain boost or a gain reduction.\r\n    We will also use the first knob to get the amount of gain we want.\r\n       \r\n    -> If the switch is checked, it is a gain reduction: we enter the first branch of the condition.\r\n    We will use our first knob to multiply the input: \r\n        - If the knob is at 0%, then 1 - KNOB_1 = 1 and our output will be equal to our input. \r\n        - If the knob is at 50%, then 1 - KNOB_1 = 0.5 so our output two times lower. \r\n        - If the knob is at 100%, then 1 - KNOB_1 = 0 and our output will be completly muted.\r\n        \r\n    -> If the switch is unchecked, it is a gain boost: we enter the else branch.\r\n        - If the knob is at 0%, then 1 - KNOB_1 = 1 and our output will be equal to our input.\r\n        - If the knob is at 50%, then 1 - KNOB_1 = 0.5 so our output two times higher.\r\n        - If the knob is at 100%, then 1 - KNOB_1 = 0 and our output have an infinite gain.\r\n*/\r\n\nformula_main {\r\n    float output;\r\n    \r\n    int isGainReduction = SWITCH_1;\r\n    \r\n    if (isGainReduction) {\r\n        output = input * (1 - KNOB_1);\r\n    }\r\n    else {\r\n        float maxGain = 5;\n        output = input / (1 - KNOB_1);\r\n    }\r\n    \n    return output;\n}\r\n\r\n/* All the knobs and switches can be automated in your DAW! */","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"...","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 2: Using controls","KnobDefaultValue9":"0.500000","CompilationId":"c2f6d792-5539-4dca-8045-3aad8ab7a2ad","Description":"You will learn to make your effect react to the controls in the knob panel.","Created":"2022-May-29 15:45:50","LastModified":"2022-May-29 20:27:29","SwitchDefaultValue0":"0","SwitchName1":"","SwitchName0":"Boost / Cut","SwitchDefaultValue1":"0","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 3: Math functions":{"KnobName1":"","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 3: Math functions\r\n\r\n    In this tutorial you will learn how to use standard math functions.\r\n    \r\n    Our previous effect had an issue: we had to use a switch to create either\r\n    a gain boost or a gain cut, and we did not have control over our maximum allowed gain.\r\n    \r\n    Hence, we will read the knob value in decibels and we will convert it to a gain.\r\n    To do so, we use the mathematical formula :\r\n        gain = 10^(decibels / 20)\r\n    \r\n    There is no built-in operator in the C language to make a power.\r\n    Hopefully, the standard mathematical library is shipped with the formulas!\r\n    You can find the list of all of its functions here: https://en.wikipedia.org/wiki/C_mathematical_functions\r\n    \r\n    Thus, we can use the 'pow(X, Y)' function to do our calculation. \r\n*/\r\n\nformula_main {\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n\r\n    float boostedOutput = input * gain;\r\n    \n    return boostedOutput;\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 3: Math functions","KnobDefaultValue9":"0.500000","CompilationId":"e42ee789-2434-42f5-a479-756b3576fc54","Description":"You will learn how to use standard math functions.","Created":"2022-May-29 16:00:56","LastModified":"2022-May-29 20:31:56","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 4: Using time":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"\r\n/*  Tutorial 4: Using time\r\n\r\n    In this tutorial you will learn how to make your formula react to the time.\r\n    \r\n    We are going to convert our simple gain plugin to an tremolo.\r\n    To do so, the gain must be modulated by an LFO.\r\n    \r\n    We will use the second knob to read the frequency for our LFO, from 0 to 10Hz.\r\n    \r\n    Then, we will create a sine wave oscillating between 0 and 1 at the frequency coming from this knob,\r\n    using the TIME value which is the amount of seconds elapsed since the launch of our plugin.\r\n    \r\n    This LFO will be multiplicated by our gain coming from the first knob, and applied to our input sample.\r\n*/\r\n\nformula_main {\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n    \r\n    float lfoFrequency = KNOB_2 * 10; // From 0 to 10Hz\r\n    float lfo = gain * sin(2 * M_PI * lfoFrequency * TIME);\r\n    \r\n    float output = input * lfo;\r\n    \n    return output;\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 4: Using time","KnobDefaultValue9":"0.500000","CompilationId":"63a5e825-1d47-4a35-86fa-01a5f65cab58","Description":"You will learn how to make your formula react to the time.","Created":"2022-May-29 16:12:06","LastModified":"2022-May-29 20:34:27","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 5: State management using globals":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 5: State management using globals\r\n\r\n    In this tutorial you will learn how you can store a value for later use.\r\n    \r\n    Sometimes, you need to compute a value using a sample and get this value back some time after.\r\n    To do so in a formula, you would declare a global variable outside of the 'formula_main {...}' block.\r\n    \r\n    Such a variable will be defined once at startup, and you could read and/or write to it in the formula_main\r\n    block. The difference with a local variable is that the value of this global variable would not be\r\n    discarded at the end of the 'formula_main' block.\r\n    \r\n    Let's add a low-pass filter on top of our LFO. \r\n    The technical implementation is out of scope, but keep in mind that such a filter\r\n    needs to know its output from the previous sample.\r\n    \r\n    What we will do, is to create a global variable called 'previousOutput'.\r\n    We will use this variable for our filter processing, and update it once we are done.\r\n    \r\n    Note that we also use the SAMPLE_RATE value, often essential to produce an invariant processing for \r\n    any sample rate coming from the host.\r\n*/\r\n\r\nfloat previousOutput = 0;\r\n\nformula_main {\r\n    // Gain section\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n    \r\n    // LFO section\r\n    float lfoFrequency = KNOB_2 * 10; // From 0 to 10Hz\r\n    float lfo = gain * sin(2 * M_PI * lfoFrequency * TIME);    \r\n    float lfoOutput = input * lfo;    \r\n    \r\n    // Filter section\r\n    float filterFrequency = 20 + KNOB_3 * 20000; // From 20Hz to 20kHz\r\n    float alpha = exp(-filterFrequency / SAMPLE_RATE);\r\n    float filterOutput = previousOutput * alpha + lfoOutput * (1 - alpha);\r\n    previousOutput = filterOutput;\r\n    \n    return filterOutput;\n}\r\n\r\n/* NOTES: \r\n    - Don't forget to initialize your global variables!\r\n    - If you declare a local variable with the same name than a global, it will overwrite it\r\n    without throwing any error!\r\n*/","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 5: State management using globals","KnobDefaultValue9":"0.500000","CompilationId":"4014377b-72a7-4251-b0fa-299dc629aa0f","Description":"You will learn how you can store a value for later use.","Created":"2022-May-29 16:33:00","LastModified":"2022-May-29 20:37:38","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 6: Going stereo":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"Panning","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 6: Going stereo\r\n\r\n    In this tutorial you will learn how to produce a different output for the left and right channels.\r\n    \r\n    Until now, all the tutorial effects were invariantly repeated for every audio channel. \r\n    But sometimes, you need to control the left and right channels independently.\r\n    \r\n    In a formula, you would use a 'formula_main_stereo {...}' block instead. The input variable would\r\n    not be a simple float value, but a Stereo variable holding two members: input.left and input.right.\r\n    \r\n    In the same way, the output that you will return has to be a Stereo variable.\r\n*/\r\n\r\nfloat previousOutput[2] = {0};\r\n\nformula_main_stereo {\r\n    // Gain section\r\n    float gainDecibels = (KNOB_1 - 0.5) * 12; // From -12dB to +12dB\r\n    float gain = pow(10, gainDecibels / 20); // Convert from decibels to gain\r\n    \r\n    // LFO section\r\n    float lfoFrequency = KNOB_2 * 10; // From 0 to 10Hz\r\n    float lfo = gain * sin(2 * M_PI * lfoFrequency * TIME);\r\n    float lfoOutputLeft = input.left * lfo;    \r\n    float lfoOutputRight = input.right * lfo; \r\n    \r\n    // Filter section\r\n    float filterFrequency = 20 + KNOB_3 * 20000; // From 20Hz to 20kHz\r\n    float alpha = exp(-filterFrequency / SAMPLE_RATE);\r\n    float filterOutputLeft = previousOutput[0] * alpha + lfoOutputLeft * (1 - alpha);\r\n    float filterOutputRight = previousOutput[1] * alpha + lfoOutputRight * (1 - alpha);\r\n    previousOutput[0] = filterOutputLeft;\r\n    previousOutput[1] = filterOutputRight;\r\n    \r\n    // Panning section\r\n    float panning = KNOB_4; // 0% = Left, 100% = Right\r\n    float panningOutputLeft = filterOutputLeft * (1 - panning);\r\n    float panningOutputRight = filterOutputRight * panning;\r\n    \r\n    Stereo output;\r\n    output.left = panningOutputLeft;\r\n    output.right = panningOutputRight;\r\n    \n    return output;\n}\r\n\r\n/* NOTES:\r\n    - We used an array to store the filter state, it is often more handy when working with\r\n    multiple channels.\r\n*/","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 6: Going stereo","KnobDefaultValue9":"0.500000","CompilationId":"1841c7b0-fa12-4da0-ae07-0cc1644a3dcc","Description":"You will learn how to produce a different output for the left and right channels.","Created":"2022-May-29 17:11:26","LastModified":"2022-May-29 20:38:57","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 7: Advanced concepts":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 7: Advanced concepts\r\n\r\n    In this tutorial you will learn about some more advanced features of Formula.\r\n    \r\n    1) Differences with C language\r\n    Formula uses a C language compiler, but there are some restrictions that apply, mostly\r\n    for security or compatibility reasons:\r\n        - You can't use the C preprocessor. If you want to #include an external library, it is not possible.\r\n        As of now, only stdlib.h and math.h are included by default.\r\n        - You can't use dynamic memory allocation at all.\r\n        \r\n    Note that if you wish to use Formula through a private Formula Cloud tenant for your company, \r\n    Soundspear can provide you a custom build where all of those restrictions are removed, \r\n    and with additional features such as C++ support and custom compilers.\r\n    \r\n    2) Debugging formulas\r\n    You might want to debug a formula if it is not doing what it is intended to do.\r\n    You can use the DEBUG(x) macro to do so: the variable you are passing to the macro will\r\n    be dumped at a fixed interval of time and you will be able to see its value using the Debug pane by\r\n    clicking on the bug icon from the sidebar.\r\n    \r\n    3) Performance\r\n    The tutorials were not focused on performance, but keep in mind that your code will run at least\r\n    44100 times per second, hence performance should be one of your primary concerns. A good practice\r\n    is to recompute most of values only if absolutly necessary, for instance if the knobs have changed.\r\n    \r\n    4) Create a VST from a formula\r\n    A formula can be compiled as C code given a library called libformula.h, that you can find in \r\n    our Github repository.\r\n*/\r\n\r\n\nformula_main {\r\n    DEBUG(input);\r\n    \r\n    return input;\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 7: Advanced concepts","KnobDefaultValue9":"0.500000","CompilationId":"6eaff75c-fda0-4a39-904b-dc701ccfab5a","Description":"You will learn about some more advanced features of Formula.","Created":"2022-May-29 17:58:53","LastModified":"2022-May-29 20:41:00","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Tutorial 8: What is Formula Cloud":{"KnobName1":"LFO (0 to 10Hz)","KnobDefaultValue0":"0.500000","KnobName0":"Gain (+/-12dB)","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"Filter (20Hz to 20kHz)","Source":"\r\n/*  Tutorial 8: What is Formula Cloud\r\n\r\n    Creating your own formulas are great, but testing formulas from the community is \r\n    even better.\r\n    \r\n    This is happening on Formula Cloud, under the third tab of this plugin.\r\n    \r\n    You can dig through hundred of innovative formulas and pick the one you need.\r\n    \r\n    You can also share any of the formulas you made from the 'Saved files' tab.\r\n    \r\n    NOTE: Formula Cloud is a paid feature available as a subscription on soundspear.com\r\n*/\r\n\r\n\nformula_main { return input; }\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Tutorial 8: What is Formula Cloud","KnobDefaultValue9":"0.500000","CompilationId":"6eaff75c-fda0-4a39-904b-dc701ccfab5a","Description":"You will be given an overview of Formula Cloud.","Created":"2022-May-29 20:46:31","LastModified":"2022-May-29 20:47:54","SwitchName1":"...","SwitchDefaultValue0":"0","SwitchDefaultValue1":"0","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","KnobName11":""},"Warmifier":{"KnobName1":"","KnobDefaultValue0":"1.000000","KnobName0":"Drive","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"/* --------------------------------- *\r\n *            Warmifier              *\r\n *                                   *\r\n * Creates a warm tone full of even  *\r\n * harmonics as in traditional tube  *\r\n * distortion.                       *\r\n *                                   *\r\n * --------------------------------- */\r\n\r\n\r\n// This type contains the state and the coefficients of a\r\n// band split crossover filter\r\ntypedef struct {\r\n    float c[2][2][6];      // [lo/hi][order][coeff]\r\n    float zIn[2][2][2];    // [lo/hi][order][input delay]\r\n    float zOut[2][2][2];   // [lo/hi][order][output delay]\r\n} LRState;\r\n\r\n// Splits an input sample into a low and a high sample using a crossover\r\nLRState xOver(float input, float* outLow, float* outHigh, LRState state) {\r\n    \r\n    float inLow = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[0][order], *b = state.c[0][order] + 3;\r\n        float *i = state.zIn[0][order], *o = state.zOut[0][order];\r\n        *outLow = (b[0]*inLow + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inLow;\r\n        o[1] = o[0]; o[0] = *outLow;\r\n        inLow = *outLow;\r\n    }\r\n    \r\n    float inHigh = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[1][order], *b = state.c[1][order] + 3;\r\n        float *i = state.zIn[1][order], *o = state.zOut[1][order];\r\n        *outHigh = (b[0]*inHigh + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inHigh;\r\n        o[1] = o[0]; o[0] = *outHigh;\r\n        inHigh = *outHigh;\r\n    }\r\n    return state;\r\n}\r\n\r\n// Initializes the coefficients for a 4th order Linqwitz-Riley crossover\r\nLRState lr4(float cutoff, LRState state) {\r\n    float Q = 1 / sqrt(2);\r\n    for (int i = 0; i < 2; ++i)\r\n    {\r\n        float w0 = 2 * M_PI * cutoff / SAMPLE_RATE;\r\n        float alpha = sin(w0) / (2*Q);\r\n        float cw = cos(w0);\r\n        \r\n        state.c[1][i][0] = state.c[0][i][0] = 1 + alpha;\r\n        state.c[1][i][1] = state.c[0][i][1] = -2 * cw;\r\n        state.c[1][i][2] = state.c[0][i][2] = 1 - alpha;        \r\n        state.c[0][i][3] = 0.5 * (1 - cw);\r\n        state.c[1][i][3] = 0.5 * (1 + cw);\r\n        state.c[0][i][4] = 1 - cw;\r\n        state.c[1][i][4] = -1 - cw;\r\n        state.c[0][i][5] = 0.5 * (1 - cw);\r\n        state.c[1][i][5] = 0.5 * (1 + cw);\r\n    }\r\n    \r\n    return state;\r\n}\r\n\r\n// To initialize the filter only once at startup\r\nint xoverInitialized = 0;\r\n\r\n// High/low crossover\r\nLRState xoverState = {{0}};\r\n// Antialiasing filter\r\nLRState antialias = {{0}};\r\n\nformula_main {\r\n\r\n    if (!xoverInitialized) {\r\n        // Initialize the crossover to split bands at 1500 Hz\r\n        xoverState = lr4(1500, xoverState);\r\n        // Initialize the antialiasing filter at 15 kHz\r\n        antialias = lr4(15000, antialias);\r\n        xoverInitialized = 1;\r\n    }\r\n\n    float high, low;\r\n    xoverState = xOver(input, &low, &high, xoverState);\r\n    \r\n    float drive = KNOB_1*0.5 + 0.5;\r\n    \r\n    // Apply an even-harmonics waveshaper to the negatively polarized samples\r\n    float x = low, x2 = x*x, x3 = x2*x;\r\n    \r\n    if (x < -0.8) {\r\n        low = 0.2533783783783784*x3 + 0.7601351351351351*x2 + x - 0.5067567567567568;\r\n        low *= drive;\r\n    }\r\n    else if (x < -0.4) {\r\n        low = 1.8369932432432432*x3 + 4.5608108108108105*x2 + 4.04054054054054*x + 0.30405405405405406;\r\n        low *= drive;\r\n    }\r\n    else if (x < 0) {\r\n        low = -2.9138513513513513*x3 - 1.1402027027027026*x2 + 1.760135135135135*x;\r\n        low *= drive;\r\n    }\r\n    else {\r\n        low = x;\r\n    }\r\n    \r\n    // Apply antialiasing\n    float keep, discard;    \r\n    antialias = xOver(low, &keep, &discard, antialias);\r\n    low = keep;\r\n    \r\n    return low + high * (1 + 0.3*(drive-0.5));\n}\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"Warmifier","KnobDefaultValue9":"0.500000","CompilationId":"0387a4b8-ab39-48df-b116-cd4d825563ca","Description":"Creates a warm tone full of even harmonics as in traditional tube distortion.","Created":"2022-Jun-04 15:51:13","LastModified":"2022-Jun-04 21:15:35","SwitchName1":"","SwitchDefaultValue0":"","SwitchDefaultValue1":"","SwitchName0":"","SwitchDefaultValue2":"","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":""},"Ultra Punch":{"KnobName1":"","KnobDefaultValue0":"1.000000","KnobName0":"Punch","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.500000","KnobName2":"","Source":"/* --------------------------------- *\r\n *          Ultra Punch              *\r\n *                                   *\r\n * Squashes a band limited input to  *\r\n * extract the juiciest punch of it. *\r\n *                                   *\r\n * --------------------------------- */\r\n \r\n \r\n \r\n// Slow, RMS style downward compressor state structure\r\ntypedef struct {\r\n    double thres, ratio, atk, rel;\r\n    double makeup, rmsSize;\r\n\r\n    double rmsBuf[10000];\r\n    double rmsSum; \r\n\tint rmsPtr;\r\n    double yold;\r\n} CompState;\r\n\r\n// Compute the RMS average from an input and a previous state\r\nfloat computeRms(float input, CompState* s) {\r\n    s->rmsSum -= s->rmsBuf[s->rmsPtr];\r\n    s->rmsBuf[s->rmsPtr] = input*input/s->rmsSize;    \r\n    s->rmsSum += s->rmsBuf[s->rmsPtr++];\r\n    \r\n    if (s->rmsPtr > s->rmsSize) {\r\n        s->rmsPtr = 0;\r\n    }\r\n    \r\n    float rms = sqrt(s->rmsSum);\r\n\t\r\n\treturn rms;\r\n}\r\n\r\n// Compress the input given the characteristics from CompState\r\nfloat compress(float input, CompState* s) {    \r\n    double rms = computeRms(input, s);  \r\n    \r\n    double x = fabs(rms);\r\n    double cte = x > s->yold ? s->atk : s->rel;\r\n    double y = x + cte * (s->yold - x);\r\n    s->yold = y;\r\n    \r\n    double gain = 1.0;\r\n    if (y > s->thres) {\r\n        gain = pow (y / s->thres, 1.0 / s->ratio - 1.0);\r\n    }    \r\n    \r\n    return gain * input * s->makeup; \r\n}\r\n\r\n// Create / Update a compressor state with given characteristics\r\nvoid updateComp(CompState* s, float thresDb, float ratio, float atkMs, float relMs, float makeupDb, float rmsSize) {\r\n    s->thres = pow (10.0, thresDb * 0.05);\r\n    s->ratio = ratio;\r\n    double scaling = -2.0 * M_PI * 1000.0 / SAMPLE_RATE;\r\n    s->atk = exp(scaling / atkMs);\r\n    s->rel = exp(scaling / relMs);\r\n    s->makeup = pow (10.0, makeupDb * 0.05);\r\n    s->rmsSize = rmsSize;\r\n}\r\n\r\n// This type contains the state and the coefficients of a\r\n// band split crossover filter\r\ntypedef struct {\r\n    float c[2][2][6];      // [lo/hi][order][coeff]\r\n    float zIn[2][2][2];    // [lo/hi][order][input delay]\r\n    float zOut[2][2][2];   // [lo/hi][order][output delay]\r\n} LRState;\r\n\r\n// Splits an input sample into a low and a high sample using a crossover\r\nLRState xOver(float input, float* outLow, float* outHigh, LRState state) {\r\n    \r\n    float inLow = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[0][order], *b = state.c[0][order] + 3;\r\n        float *i = state.zIn[0][order], *o = state.zOut[0][order];\r\n        *outLow = (b[0]*inLow + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inLow;\r\n        o[1] = o[0]; o[0] = *outLow;\r\n        inLow = *outLow;\r\n    }\r\n    \r\n    float inHigh = input;\r\n    for (int order = 0; order < 2; order++) {\r\n        float *a = state.c[1][order], *b = state.c[1][order] + 3;\r\n        float *i = state.zIn[1][order], *o = state.zOut[1][order];\r\n        *outHigh = (b[0]*inHigh + b[1]*i[0] + b[2]*i[1] - a[1]*o[0] - a[2]*o[1]) / a[0];\r\n        i[1] = i[0]; i[0] = inHigh;\r\n        o[1] = o[0]; o[0] = *outHigh;\r\n        inHigh = *outHigh;\r\n    }\r\n    return state;\r\n}\r\n\r\n// Initializes the coefficients for a 4th order Linqwitz-Riley crossover\r\nLRState lr4(float cutoff, LRState state) {\r\n    float Q = 1 / sqrt(2);\r\n    for (int i = 0; i < 2; ++i)\r\n    {\r\n        float w0 = 2 * M_PI * cutoff / SAMPLE_RATE;\r\n        float alpha = sin(w0) / (2*Q);\r\n        float cw = cos(w0);\r\n        \r\n        state.c[1][i][0] = state.c[0][i][0] = 1 + alpha;\r\n        state.c[1][i][1] = state.c[0][i][1] = -2 * cw;\r\n        state.c[1][i][2] = state.c[0][i][2] = 1 - alpha;        \r\n        state.c[0][i][3] = 0.5 * (1 - cw);\r\n        state.c[1][i][3] = 0.5 * (1 + cw);\r\n        state.c[0][i][4] = 1 - cw;\r\n        state.c[1][i][4] = -1 - cw;\r\n        state.c[0][i][5] = 0.5 * (1 - cw);\r\n        state.c[1][i][5] = 0.5 * (1 + cw);\r\n    }\r\n    \r\n    return state;\r\n}\r\n\r\n// To initialize the filter only once at startup\r\nint xoverInitialized = 0;\r\n\r\nfloat prevThres = 1;\r\n\r\nLRState xbass = {{0}};\r\nLRState xhigh = {{0}};\r\nCompState compBass = {{0}}, compMid = {{0}}, compHigh = {{0}};\r\n\r\nformula_main {\r\n\r\n    if (!xoverInitialized) {\r\n        xbass = lr4(150, xbass);\r\n        xhigh = lr4(2500, xhigh);\r\n    }\r\n    if (prevThres != KNOB_1 * -20) {\r\n        updateComp(&compBass, KNOB_1 * -30, 2, 5, 20, KNOB_1 * 6, 10);\r\n        updateComp(&compMid, KNOB_1 * -30, 3, 5, 10, KNOB_1 * 2.5, 3);\r\n        updateComp(&compHigh, KNOB_1 * -30, 10, 15, 50, KNOB_1 * 2.5, 100);\r\n        prevThres = KNOB_1 * -20;   \r\n    }\r\n    \r\n    float bass, mid, high;\r\n    \r\n    xbass = xOver(input, &bass, &mid, xbass);\r\n    xhigh = xOver(mid, &mid, &high, xhigh);    \r\n    \r\n    bass = compress(bass, &compBass);    \r\n    mid = compress(mid, &compMid);\r\n    high = compress(high, &compHigh);\r\n    \r\n    return bass + mid + high;\r\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","Name":"Ultra Punch","KnobName8":"","KnobDefaultValue9":"0.500000","CompilationId":"69093bce-02df-4860-9fc3-7103982b0dea","SwitchName1":"","SwitchDefaultValue0":"0","SwitchName0":"","SwitchDefaultValue1":"0","Description":"Squashes a band limited input to extract the juiciest punch of it.","Created":"2022-Jun-12 13:31:52","LastModified":"2022-Jun-12 13:31:52","SwitchDefaultValue2":"0","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":""},"FireAmp (Airwindows)":{"KnobName1":"Tone","KnobDefaultValue0":"0.500000","KnobName0":"Gain","KnobDefaultValue1":"0.500000","KnobName3":"","KnobDefaultValue2":"0.800000","KnobName2":"Output","Source":"/* ========================================\r\n *  FireAmp - FireAmp.h\r\n *  Copyright (c) 2016 airwindows, All rights reserved\r\n * ======================================== */\r\n\r\ndouble lastSampleL = 0.0;\r\ndouble storeSampleL = 0.0;\r\ndouble smoothAL = 0.0;\r\ndouble smoothBL = 0.0;\r\ndouble smoothCL = 0.0;\r\ndouble smoothDL = 0.0;\r\ndouble smoothEL = 0.0;\r\ndouble smoothFL = 0.0;\r\ndouble smoothGL = 0.0;\r\ndouble smoothHL = 0.0;\r\ndouble smoothIL = 0.0;\r\ndouble smoothJL = 0.0;\r\ndouble smoothKL = 0.0;\r\ndouble smoothLL = 0.0;\r\ndouble iirSampleAL = 0.0;\r\ndouble iirSampleBL = 0.0;\r\ndouble iirSampleCL = 0.0;\r\ndouble iirSampleDL = 0.0;\r\ndouble iirSampleEL = 0.0;\r\ndouble iirSampleFL = 0.0;\r\ndouble iirSampleGL = 0.0;\r\ndouble iirSampleHL = 0.0;\r\ndouble iirSampleIL = 0.0;\r\ndouble iirSampleJL = 0.0;\r\ndouble iirSampleKL = 0.0;\r\ndouble iirSampleLL = 0.0;\r\ndouble iirLowpassL = 0.0;\r\ndouble iirSpkAL = 0.0;\r\ndouble iirSpkBL = 0.0;\r\ndouble iirSubL = 0.0;\r\ndouble OddL[257] = {0.0};\r\ndouble EvenL[257] = {0.0};\r\n\r\ndouble lastSampleR = 0.0;\r\ndouble storeSampleR = 0.0;\r\ndouble smoothAR = 0.0;\r\ndouble smoothBR = 0.0;\r\ndouble smoothCR = 0.0;\r\ndouble smoothDR = 0.0;\r\ndouble smoothER = 0.0;\r\ndouble smoothFR = 0.0;\r\ndouble smoothGR = 0.0;\r\ndouble smoothHR = 0.0;\r\ndouble smoothIR = 0.0;\r\ndouble smoothJR = 0.0;\r\ndouble smoothKR = 0.0;\r\ndouble smoothLR = 0.0;\r\ndouble iirSampleAR = 0.0;\r\ndouble iirSampleBR = 0.0;\r\ndouble iirSampleCR = 0.0;\r\ndouble iirSampleDR = 0.0;\r\ndouble iirSampleER = 0.0;\r\ndouble iirSampleFR = 0.0;\r\ndouble iirSampleGR = 0.0;\r\ndouble iirSampleHR = 0.0;\r\ndouble iirSampleIR = 0.0;\r\ndouble iirSampleJR = 0.0;\r\ndouble iirSampleKR = 0.0;\r\ndouble iirSampleLR = 0.0;\r\ndouble iirLowpassR = 0.0;\r\ndouble iirSpkAR = 0.0;\r\ndouble iirSpkBR = 0.0;\r\ndouble iirSubR = 0.0;\r\ndouble OddR[257] = {0.0};\r\ndouble EvenR[257] = {0.0};\r\n\r\nint flip = 0;\r\nint count = 0; //amp\r\n\r\ndouble bL[90] = {0.0};\r\ndouble lastCabSampleL = 0.0;\r\ndouble smoothCabAL = 0.0;\r\ndouble smoothCabBL = 0.0; //cab\r\n\r\ndouble bR[90] = {0.0};\r\ndouble lastCabSampleR = 0.0;\r\ndouble smoothCabAR = 0.0;\r\ndouble smoothCabBR = 0.0; //cab\r\n\r\ndouble lastRefL[10] = {0.0};\r\ndouble lastRefR[10] = {0.0};\r\nint cycle = 0;\t//undersampling\r\n\r\nenum {\r\n\tfix_freq,\r\n\tfix_reso,\r\n\tfix_a0,\r\n\tfix_a1,\r\n\tfix_a2,\r\n\tfix_b1,\r\n\tfix_b2,\r\n\tfix_sL1,\r\n\tfix_sL2,\r\n\tfix_sR1,\r\n\tfix_sR2,\r\n\tfix_total\r\n}; //fixed frequency biquad filter for ultrasonics, stereo\r\ndouble fixA[fix_total] = {0.0};\r\ndouble fixB[fix_total] = {0.0};\r\ndouble fixC[fix_total] = {0.0};\r\ndouble fixD[fix_total] = {0.0};\r\ndouble fixE[fix_total] = {0.0};\r\ndouble fixF[fix_total] = {0.0}; //filtering\r\n\r\nuint32_t fpdL = 0xdeadbeef;\r\nuint32_t fpdR = 0xcafebabe;\r\n//default stuff\r\n\r\n\t\r\nformula_main_stereo {\r\n\r\n\tdouble bassfill = KNOB_1;\r\n\tdouble outputlevel = KNOB_3;\r\n\t\r\n\tdouble overallscale = 1.0;\r\n\toverallscale /= 44100.0;\r\n\toverallscale *= SAMPLE_RATE;\r\n\tint cycleEnd = floor(overallscale);\r\n\tif (cycleEnd < 1) cycleEnd = 1;\r\n\tif (cycleEnd > 4) cycleEnd = 4;\r\n\t//this is going to be 2 for 88.1 or 96k, 3 for silly people, 4 for 176 or 192k\r\n\tif (cycle > cycleEnd-1) cycle = cycleEnd-1; //sanity check\t\t\r\n\t\r\n\tdouble startlevel = bassfill;\r\n\tdouble samplerate = SAMPLE_RATE;\r\n\tdouble basstrim = bassfill / 16.0;\r\n\tdouble toneEQ = (KNOB_2 / samplerate)*22050.0;\r\n\tdouble EQ = (basstrim / samplerate)*22050.0;\r\n\tdouble bleed = outputlevel/16.0;\r\n\tdouble bassfactor = 1.0-(basstrim*basstrim);\r\n\tdouble BEQ = (bleed / samplerate)*22050.0;\r\n\tint diagonal = (int)(0.000861678*samplerate);\r\n\tif (diagonal > 127) diagonal = 127;\r\n\tint side = (int)(diagonal/1.4142135623730951);\r\n\tint down = (side + diagonal)/2;\r\n\t//now we've got down, side and diagonal as offsets and we also use three successive samples upfront\r\n\t\r\n\tdouble cutoff = (15000.0+(KNOB_2*10000.0)) / SAMPLE_RATE;\r\n\tif (cutoff > 0.49) cutoff = 0.49; //don't crash if run at 44.1k\r\n\tif (cutoff < 0.001) cutoff = 0.001; //or if cutoff's too low\r\n\t\r\n\tfixF[fix_freq] = fixE[fix_freq] = fixD[fix_freq] = fixC[fix_freq] = fixB[fix_freq] = fixA[fix_freq] = cutoff;\r\n\t\r\n    fixA[fix_reso] = 4.46570214;\r\n\tfixB[fix_reso] = 1.51387132;\r\n\tfixC[fix_reso] = 0.93979296;\r\n\tfixD[fix_reso] = 0.70710678;\r\n\tfixE[fix_reso] = 0.52972649;\r\n\tfixF[fix_reso] = 0.50316379;\r\n\t\r\n\tdouble K = tan(M_PI * fixA[fix_freq]); //lowpass\r\n\tdouble norm = 1.0 / (1.0 + K / fixA[fix_reso] + K * K);\r\n\tfixA[fix_a0] = K * K * norm;\r\n\tfixA[fix_a1] = 2.0 * fixA[fix_a0];\r\n\tfixA[fix_a2] = fixA[fix_a0];\r\n\tfixA[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixA[fix_b2] = (1.0 - K / fixA[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixB[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixB[fix_reso] + K * K);\r\n\tfixB[fix_a0] = K * K * norm;\r\n\tfixB[fix_a1] = 2.0 * fixB[fix_a0];\r\n\tfixB[fix_a2] = fixB[fix_a0];\r\n\tfixB[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixB[fix_b2] = (1.0 - K / fixB[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixC[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixC[fix_reso] + K * K);\r\n\tfixC[fix_a0] = K * K * norm;\r\n\tfixC[fix_a1] = 2.0 * fixC[fix_a0];\r\n\tfixC[fix_a2] = fixC[fix_a0];\r\n\tfixC[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixC[fix_b2] = (1.0 - K / fixC[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixD[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixD[fix_reso] + K * K);\r\n\tfixD[fix_a0] = K * K * norm;\r\n\tfixD[fix_a1] = 2.0 * fixD[fix_a0];\r\n\tfixD[fix_a2] = fixD[fix_a0];\r\n\tfixD[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixD[fix_b2] = (1.0 - K / fixD[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixE[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixE[fix_reso] + K * K);\r\n\tfixE[fix_a0] = K * K * norm;\r\n\tfixE[fix_a1] = 2.0 * fixE[fix_a0];\r\n\tfixE[fix_a2] = fixE[fix_a0];\r\n\tfixE[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixE[fix_b2] = (1.0 - K / fixE[fix_reso] + K * K) * norm;\r\n\t\r\n\tK = tan(M_PI * fixF[fix_freq]);\r\n\tnorm = 1.0 / (1.0 + K / fixF[fix_reso] + K * K);\r\n\tfixF[fix_a0] = K * K * norm;\r\n\tfixF[fix_a1] = 2.0 * fixF[fix_a0];\r\n\tfixF[fix_a2] = fixF[fix_a0];\r\n\tfixF[fix_b1] = 2.0 * (K * K - 1.0) * norm;\r\n\tfixF[fix_b2] = (1.0 - K / fixF[fix_reso] + K * K) * norm;\r\n\t\r\n\tdouble inputSampleL = input.left;\r\n\tdouble inputSampleR = input.right;\r\n\tif (fabs(inputSampleL)<1.18e-23) inputSampleL = fpdL * 1.18e-17;\r\n\tif (fabs(inputSampleR)<1.18e-23) inputSampleR = fpdR * 1.18e-17;\r\n\tdouble drySampleL = inputSampleL;\r\n\tdouble drySampleR = inputSampleR;\r\n\r\n\r\n\tdouble outSample = (inputSampleL * fixA[fix_a0]) + fixA[fix_sL1];\r\n\tfixA[fix_sL1] = (inputSampleL * fixA[fix_a1]) - (outSample * fixA[fix_b1]) + fixA[fix_sL2];\r\n\tfixA[fix_sL2] = (inputSampleL * fixA[fix_a2]) - (outSample * fixA[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixA[fix_a0]) + fixA[fix_sR1];\r\n\tfixA[fix_sR1] = (inputSampleR * fixA[fix_a1]) - (outSample * fixA[fix_b1]) + fixA[fix_sR2];\r\n\tfixA[fix_sR2] = (inputSampleR * fixA[fix_a2]) - (outSample * fixA[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tif (inputSampleL > 1.0) inputSampleL = 1.0;\r\n\tif (inputSampleL < -1.0) inputSampleL = -1.0;\r\n\tdouble basscutL = 0.98;\r\n\t//we're going to be shifting this as the stages progress\r\n\tdouble inputlevelL = startlevel;\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleAL = (iirSampleAL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleAL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tdouble bridgerectifier = (smoothAL + inputSampleL);\r\n\tsmoothAL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleBL = (iirSampleBL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleBL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothBL + inputSampleL);\r\n\tsmoothBL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\tif (inputSampleR > 1.0) inputSampleR = 1.0;\r\n\tif (inputSampleR < -1.0) inputSampleR = -1.0;\r\n\tdouble basscutR = 0.98;\r\n\t//we're going to be shifting this as the stages progress\r\n\tdouble inputlevelR = startlevel;\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleAR = (iirSampleAR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleAR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothAR + inputSampleR);\r\n\tsmoothAR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleBR = (iirSampleBR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleBR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothBR + inputSampleR);\r\n\tsmoothBR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\toutSample = (inputSampleL * fixB[fix_a0]) + fixB[fix_sL1];\r\n\tfixB[fix_sL1] = (inputSampleL * fixB[fix_a1]) - (outSample * fixB[fix_b1]) + fixB[fix_sL2];\r\n\tfixB[fix_sL2] = (inputSampleL * fixB[fix_a2]) - (outSample * fixB[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixB[fix_a0]) + fixB[fix_sR1];\r\n\tfixB[fix_sR1] = (inputSampleR * fixB[fix_a1]) - (outSample * fixB[fix_b1]) + fixB[fix_sR2];\r\n\tfixB[fix_sR2] = (inputSampleR * fixB[fix_a2]) - (outSample * fixB[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleCL = (iirSampleCL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleCL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothCL + inputSampleL);\r\n\tsmoothCL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleDL = (iirSampleDL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleDL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothDL + inputSampleL);\r\n\tsmoothDL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleCR = (iirSampleCR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleCR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothCR + inputSampleR);\r\n\tsmoothCR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleDR = (iirSampleDR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleDR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654) );\r\n\t//overdrive\r\n\tbridgerectifier = (smoothDR + inputSampleR);\r\n\tsmoothDR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixC[fix_a0]) + fixC[fix_sL1];\r\n\tfixC[fix_sL1] = (inputSampleL * fixC[fix_a1]) - (outSample * fixC[fix_b1]) + fixC[fix_sL2];\r\n\tfixC[fix_sL2] = (inputSampleL * fixC[fix_a2]) - (outSample * fixC[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixC[fix_a0]) + fixC[fix_sR1];\r\n\tfixC[fix_sR1] = (inputSampleR * fixC[fix_a1]) - (outSample * fixC[fix_b1]) + fixC[fix_sR2];\r\n\tfixC[fix_sR2] = (inputSampleR * fixC[fix_a2]) - (outSample * fixC[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleEL = (iirSampleEL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleEL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothEL + inputSampleL);\r\n\tsmoothEL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleFL = (iirSampleFL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleFL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothFL + inputSampleL);\r\n\tsmoothFL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleER = (iirSampleER * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleER*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothER + inputSampleR);\r\n\tsmoothER = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleFR = (iirSampleFR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleFR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothFR + inputSampleR);\r\n\tsmoothFR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixD[fix_a0]) + fixD[fix_sL1];\r\n\tfixD[fix_sL1] = (inputSampleL * fixD[fix_a1]) - (outSample * fixD[fix_b1]) + fixD[fix_sL2];\r\n\tfixD[fix_sL2] = (inputSampleL * fixD[fix_a2]) - (outSample * fixD[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixD[fix_a0]) + fixD[fix_sR1];\r\n\tfixD[fix_sR1] = (inputSampleR * fixD[fix_a1]) - (outSample * fixD[fix_b1]) + fixD[fix_sR2];\r\n\tfixD[fix_sR2] = (inputSampleR * fixD[fix_a2]) - (outSample * fixD[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleGL = (iirSampleGL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleGL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothGL + inputSampleL);\r\n\tsmoothGL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleHL = (iirSampleHL * (1.0 - EQ)) + (inputSampleL * EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleHL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothHL + inputSampleL);\r\n\tsmoothHL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleGR = (iirSampleGR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleGR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothGR + inputSampleR);\r\n\tsmoothGR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleHR = (iirSampleHR * (1.0 - EQ)) + (inputSampleR * EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleHR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothHR + inputSampleR);\r\n\tsmoothHR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixE[fix_a0]) + fixE[fix_sL1];\r\n\tfixE[fix_sL1] = (inputSampleL * fixE[fix_a1]) - (outSample * fixE[fix_b1]) + fixE[fix_sL2];\r\n\tfixE[fix_sL2] = (inputSampleL * fixE[fix_a2]) - (outSample * fixE[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixE[fix_a0]) + fixE[fix_sR1];\r\n\tfixE[fix_sR1] = (inputSampleR * fixE[fix_a1]) - (outSample * fixE[fix_b1]) + fixE[fix_sR2];\r\n\tfixE[fix_sR2] = (inputSampleR * fixE[fix_a2]) - (outSample * fixE[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleIL = (iirSampleIL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleIL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothIL + inputSampleL);\r\n\tsmoothIL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleJL = (iirSampleJL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleJL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothJL + inputSampleL);\r\n\tsmoothJL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleIR = (iirSampleIR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleIR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothIR + inputSampleR);\r\n\tsmoothIR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleJR = (iirSampleJR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleJR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothJR + inputSampleR);\r\n\tsmoothJR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\toutSample = (inputSampleL * fixF[fix_a0]) + fixF[fix_sL1];\r\n\tfixF[fix_sL1] = (inputSampleL * fixF[fix_a1]) - (outSample * fixF[fix_b1]) + fixF[fix_sL2];\r\n\tfixF[fix_sL2] = (inputSampleL * fixF[fix_a2]) - (outSample * fixF[fix_b2]);\r\n\tinputSampleL = outSample; //fixed biquad filtering ultrasonics\r\n\toutSample = (inputSampleR * fixF[fix_a0]) + fixF[fix_sR1];\r\n\tfixF[fix_sR1] = (inputSampleR * fixF[fix_a1]) - (outSample * fixF[fix_b1]) + fixF[fix_sR2];\r\n\tfixF[fix_sR2] = (inputSampleR * fixF[fix_a2]) - (outSample * fixF[fix_b2]);\r\n\tinputSampleR = outSample; //fixed biquad filtering ultrasonics\r\n\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleKL = (iirSampleKL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleKL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothKL + inputSampleL);\r\n\tsmoothKL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleL *= inputlevelL;\r\n\tinputlevelL = ((inputlevelL * 7.0)+1.0)/8.0;\r\n\tiirSampleLL = (iirSampleLL * (1.0 - EQ)) + (inputSampleL *  EQ);\r\n\tbasscutL *= bassfactor;\r\n\tinputSampleL = inputSampleL - (iirSampleLL*basscutL);\r\n\t//highpass\r\n\tinputSampleL -= (inputSampleL * (fabs(inputSampleL) * 0.654) * (fabs(inputSampleL) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothLL + inputSampleL);\r\n\tsmoothLL = inputSampleL;\r\n\tinputSampleL = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleKR = (iirSampleKR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleKR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothKR + inputSampleR);\r\n\tsmoothKR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\tinputSampleR *= inputlevelR;\r\n\tinputlevelR = ((inputlevelR * 7.0)+1.0)/8.0;\r\n\tiirSampleLR = (iirSampleLR * (1.0 - EQ)) + (inputSampleR *  EQ);\r\n\tbasscutR *= bassfactor;\r\n\tinputSampleR = inputSampleR - (iirSampleLR*basscutR);\r\n\t//highpass\r\n\tinputSampleR -= (inputSampleR * (fabs(inputSampleR) * 0.654) * (fabs(inputSampleR) * 0.654));\r\n\t//overdrive\r\n\tbridgerectifier = (smoothLR + inputSampleR);\r\n\tsmoothLR = inputSampleR;\r\n\tinputSampleR = bridgerectifier;\r\n\t//two-sample averaging lowpass\r\n\r\n\tiirLowpassL = (iirLowpassL * (1.0 - toneEQ)) + (inputSampleL * toneEQ);\r\n\tinputSampleL = iirLowpassL;\r\n\t//lowpass. The only one of this type.\r\n\tiirLowpassR = (iirLowpassR * (1.0 - toneEQ)) + (inputSampleR * toneEQ);\r\n\tinputSampleR = iirLowpassR;\r\n\t//lowpass. The only one of this type.\r\n\r\n\tiirSpkAL = (iirSpkAL * (1.0 -  BEQ)) + (inputSampleL * BEQ);\r\n\t//extra lowpass for 4*12\" speakers\r\n\tiirSpkAR = (iirSpkAR * (1.0 -  BEQ)) + (inputSampleR * BEQ);\r\n\t//extra lowpass for 4*12\" speakers\r\n\r\n\tif (count < 0 || count > 128) {count = 128;}\r\n\tdouble resultBL = 0.0;\r\n\tdouble resultBR = 0.0;\r\n\tif (flip)\r\n\t{\r\n\t\tOddL[count+128] = OddL[count] = iirSpkAL;\r\n\t\tresultBL = (OddL[count+down] + OddL[count+side] + OddL[count+diagonal]);\r\n\t\tOddR[count+128] = OddR[count] = iirSpkAR;\r\n\t\tresultBR = (OddR[count+down] + OddR[count+side] + OddR[count+diagonal]);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tEvenL[count+128] = EvenL[count] = iirSpkAL;\r\n\t\tresultBL = (EvenL[count+down] + EvenL[count+side] + EvenL[count+diagonal]);\r\n\t\tEvenR[count+128] = EvenR[count] = iirSpkAR;\r\n\t\tresultBR = (EvenR[count+down] + EvenR[count+side] + EvenR[count+diagonal]);\r\n\t}\r\n\tcount--;\r\n\tiirSpkBL = (iirSpkBL * (1.0 - BEQ)) + (resultBL * BEQ);\r\n\tinputSampleL += (iirSpkBL * bleed);\r\n\t//extra lowpass for 4*12\" speakers\r\n\tiirSpkBR = (iirSpkBR * (1.0 - BEQ)) + (resultBR * BEQ);\r\n\tinputSampleR += (iirSpkBR * bleed);\r\n\t//extra lowpass for 4*12\" speakers\r\n\r\n\tbridgerectifier = fabs(inputSampleL*outputlevel);\r\n\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\tbridgerectifier = sin(bridgerectifier);\r\n\tif (inputSampleL > 0) inputSampleL = bridgerectifier;\r\n\telse inputSampleL = -bridgerectifier;\r\n\r\n\tbridgerectifier = fabs(inputSampleR*outputlevel);\r\n\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\tbridgerectifier = sin(bridgerectifier);\r\n\tif (inputSampleR > 0) inputSampleR = bridgerectifier;\r\n\telse inputSampleR = -bridgerectifier;\r\n\r\n\tiirSubL = (iirSubL * (1.0 - BEQ)) + (inputSampleL * BEQ);\r\n\tinputSampleL += (iirSubL * bassfill * outputlevel);\r\n\r\n\tiirSubR = (iirSubR * (1.0 - BEQ)) + (inputSampleR * BEQ);\r\n\tinputSampleR += (iirSubR * bassfill * outputlevel);\r\n\r\n\tdouble randy = (((double)(fpdL)/0xffffffff)*0.053);\r\n\tinputSampleL = ((inputSampleL*(1.0-randy))+(storeSampleL*randy))*outputlevel;\r\n\tstoreSampleL = inputSampleL;\r\n\r\n\trandy = (((double)(fpdR)/0xffffffff)*0.053);\r\n\tinputSampleR = ((inputSampleR*(1.0-randy))+(storeSampleR*randy))*outputlevel;\r\n\tstoreSampleR = inputSampleR;\r\n\r\n\tflip = flip == 0 ? 1 : 0;\r\n\r\n\t//amp\r\n\r\n\tcycle++;\r\n\tif (cycle == cycleEnd) {\r\n\t\tdouble temp = (inputSampleL + smoothCabAL)/3.0;\r\n\t\tsmoothCabAL = inputSampleL;\r\n\t\tinputSampleL = temp;\r\n\t\t\r\n\t\tbL[84] = bL[83]; bL[83] = bL[82]; bL[82] = bL[81]; bL[81] = bL[80]; bL[80] = bL[79]; \r\n\t\tbL[79] = bL[78]; bL[78] = bL[77]; bL[77] = bL[76]; bL[76] = bL[75]; bL[75] = bL[74]; bL[74] = bL[73]; bL[73] = bL[72]; bL[72] = bL[71]; \r\n\t\tbL[71] = bL[70]; bL[70] = bL[69]; bL[69] = bL[68]; bL[68] = bL[67]; bL[67] = bL[66]; bL[66] = bL[65]; bL[65] = bL[64]; bL[64] = bL[63]; \r\n\t\tbL[63] = bL[62]; bL[62] = bL[61]; bL[61] = bL[60]; bL[60] = bL[59]; bL[59] = bL[58]; bL[58] = bL[57]; bL[57] = bL[56]; bL[56] = bL[55]; \r\n\t\tbL[55] = bL[54]; bL[54] = bL[53]; bL[53] = bL[52]; bL[52] = bL[51]; bL[51] = bL[50]; bL[50] = bL[49]; bL[49] = bL[48]; bL[48] = bL[47]; \r\n\t\tbL[47] = bL[46]; bL[46] = bL[45]; bL[45] = bL[44]; bL[44] = bL[43]; bL[43] = bL[42]; bL[42] = bL[41]; bL[41] = bL[40]; bL[40] = bL[39]; \r\n\t\tbL[39] = bL[38]; bL[38] = bL[37]; bL[37] = bL[36]; bL[36] = bL[35]; bL[35] = bL[34]; bL[34] = bL[33]; bL[33] = bL[32]; bL[32] = bL[31]; \r\n\t\tbL[31] = bL[30]; bL[30] = bL[29]; bL[29] = bL[28]; bL[28] = bL[27]; bL[27] = bL[26]; bL[26] = bL[25]; bL[25] = bL[24]; bL[24] = bL[23]; \r\n\t\tbL[23] = bL[22]; bL[22] = bL[21]; bL[21] = bL[20]; bL[20] = bL[19]; bL[19] = bL[18]; bL[18] = bL[17]; bL[17] = bL[16]; bL[16] = bL[15]; \r\n\t\tbL[15] = bL[14]; bL[14] = bL[13]; bL[13] = bL[12]; bL[12] = bL[11]; bL[11] = bL[10]; bL[10] = bL[9]; bL[9] = bL[8]; bL[8] = bL[7]; \r\n\t\tbL[7] = bL[6]; bL[6] = bL[5]; bL[5] = bL[4]; bL[4] = bL[3]; bL[3] = bL[2]; bL[2] = bL[1]; bL[1] = bL[0]; bL[0] = inputSampleL;\r\n\t\tinputSampleL += (bL[1] * (1.31698250313308396  - (0.08140616497621633*fabs(bL[1]))));\r\n\t\tinputSampleL += (bL[2] * (1.47229016949915326  - (0.27680278993637253*fabs(bL[2]))));\r\n\t\tinputSampleL += (bL[3] * (1.30410109086044956  - (0.35629113432046489*fabs(bL[3]))));\r\n\t\tinputSampleL += (bL[4] * (0.81766210474551260  - (0.26808782337659753*fabs(bL[4]))));\r\n\t\tinputSampleL += (bL[5] * (0.19868872545506663  - (0.11105517193919669*fabs(bL[5]))));\r\n\t\tinputSampleL -= (bL[6] * (0.39115909132567039  - (0.12630622002682679*fabs(bL[6]))));\r\n\t\tinputSampleL -= (bL[7] * (0.76881891559343574  - (0.40879849500403143*fabs(bL[7]))));\r\n\t\tinputSampleL -= (bL[8] * (0.87146861782680340  - (0.59529560488000599*fabs(bL[8]))));\r\n\t\tinputSampleL -= (bL[9] * (0.79504575932563670  - (0.60877047551611796*fabs(bL[9]))));\r\n\t\tinputSampleL -= (bL[10] * (0.61653017622406314  - (0.47662851438557335*fabs(bL[10]))));\r\n\t\tinputSampleL -= (bL[11] * (0.40718195794382067  - (0.24955839378539713*fabs(bL[11]))));\r\n\t\tinputSampleL -= (bL[12] * (0.31794900040616203  - (0.04169792259600613*fabs(bL[12]))));\r\n\t\tinputSampleL -= (bL[13] * (0.41075032540217843  + (0.00368483996076280*fabs(bL[13]))));\r\n\t\tinputSampleL -= (bL[14] * (0.56901352922170667  - (0.11027360805893105*fabs(bL[14]))));\r\n\t\tinputSampleL -= (bL[15] * (0.62443222391889264  - (0.22198075154245228*fabs(bL[15]))));\r\n\t\tinputSampleL -= (bL[16] * (0.53462856723129204  - (0.22933544545324852*fabs(bL[16]))));\r\n\t\tinputSampleL -= (bL[17] * (0.34441703361995046  - (0.12956809502269492*fabs(bL[17]))));\r\n\t\tinputSampleL -= (bL[18] * (0.13947052337867882  + (0.00339775055962799*fabs(bL[18]))));\r\n\t\tinputSampleL += (bL[19] * (0.03771252648928484  - (0.10863931549251718*fabs(bL[19]))));\r\n\t\tinputSampleL += (bL[20] * (0.18280210770271693  - (0.17413646599296417*fabs(bL[20]))));\r\n\t\tinputSampleL += (bL[21] * (0.24621986701761467  - (0.14547053270435095*fabs(bL[21]))));\r\n\t\tinputSampleL += (bL[22] * (0.22347075142737360  - (0.02493869490104031*fabs(bL[22]))));\r\n\t\tinputSampleL += (bL[23] * (0.14346348482123716  + (0.11284054747963246*fabs(bL[23]))));\r\n\t\tinputSampleL += (bL[24] * (0.00834364862916028  + (0.24284684053733926*fabs(bL[24]))));\r\n\t\tinputSampleL -= (bL[25] * (0.11559740296078347  - (0.32623054435304538*fabs(bL[25]))));\r\n\t\tinputSampleL -= (bL[26] * (0.18067604561283060  - (0.32311481551122478*fabs(bL[26]))));\r\n\t\tinputSampleL -= (bL[27] * (0.22927997789035612  - (0.26991539052832925*fabs(bL[27]))));\r\n\t\tinputSampleL -= (bL[28] * (0.28487666578669446  - (0.22437227250279349*fabs(bL[28]))));\r\n\t\tinputSampleL -= (bL[29] * (0.31992973037153838  - (0.15289876100963865*fabs(bL[29]))));\r\n\t\tinputSampleL -= (bL[30] * (0.35174606303520733  - (0.05656293023086628*fabs(bL[30]))));\r\n\t\tinputSampleL -= (bL[31] * (0.36894898011375254  + (0.04333925421463558*fabs(bL[31]))));\r\n\t\tinputSampleL -= (bL[32] * (0.32567576055307507  + (0.14594589410921388*fabs(bL[32]))));\r\n\t\tinputSampleL -= (bL[33] * (0.27440135050585784  + (0.15529667398122521*fabs(bL[33]))));\r\n\t\tinputSampleL -= (bL[34] * (0.21998973785078091  + (0.05083553737157104*fabs(bL[34]))));\r\n\t\tinputSampleL -= (bL[35] * (0.10323624876862457  - (0.04651829594199963*fabs(bL[35]))));\r\n\t\tinputSampleL += (bL[36] * (0.02091603687851074  + (0.12000046818439322*fabs(bL[36]))));\r\n\t\tinputSampleL += (bL[37] * (0.11344930914138468  + (0.17697142512225839*fabs(bL[37]))));\r\n\t\tinputSampleL += (bL[38] * (0.22766779627643968  + (0.13645102964003858*fabs(bL[38]))));\r\n\t\tinputSampleL += (bL[39] * (0.38378309953638229  - (0.01997653307333791*fabs(bL[39]))));\r\n\t\tinputSampleL += (bL[40] * (0.52789400804568076  - (0.21409137428422448*fabs(bL[40]))));\r\n\t\tinputSampleL += (bL[41] * (0.55444630296938280  - (0.32331980931576626*fabs(bL[41]))));\r\n\t\tinputSampleL += (bL[42] * (0.42333237669264601  - (0.26855847463044280*fabs(bL[42]))));\r\n\t\tinputSampleL += (bL[43] * (0.21942831522035078  - (0.12051365248820624*fabs(bL[43]))));\r\n\t\tinputSampleL -= (bL[44] * (0.00584169427830633  - (0.03706970171280329*fabs(bL[44]))));\r\n\t\tinputSampleL -= (bL[45] * (0.24279799124660351  - (0.17296440491477982*fabs(bL[45]))));\r\n\t\tinputSampleL -= (bL[46] * (0.40173760787507085  - (0.21717989835163351*fabs(bL[46]))));\r\n\t\tinputSampleL -= (bL[47] * (0.43930035724188155  - (0.16425928481378199*fabs(bL[47]))));\r\n\t\tinputSampleL -= (bL[48] * (0.41067765934041811  - (0.10390115786636855*fabs(bL[48]))));\r\n\t\tinputSampleL -= (bL[49] * (0.34409235547165967  - (0.07268159377411920*fabs(bL[49]))));\r\n\t\tinputSampleL -= (bL[50] * (0.26542883122568151  - (0.05483457497365785*fabs(bL[50]))));\r\n\t\tinputSampleL -= (bL[51] * (0.22024754776138800  - (0.06484897950087598*fabs(bL[51]))));\r\n\t\tinputSampleL -= (bL[52] * (0.20394367993632415  - (0.08746309731952180*fabs(bL[52]))));\r\n\t\tinputSampleL -= (bL[53] * (0.17565242431124092  - (0.07611309538078760*fabs(bL[53]))));\r\n\t\tinputSampleL -= (bL[54] * (0.10116623231246825  - (0.00642818706295112*fabs(bL[54]))));\r\n\t\tinputSampleL -= (bL[55] * (0.00782648272053632  + (0.08004141267685004*fabs(bL[55]))));\r\n\t\tinputSampleL += (bL[56] * (0.05059046006747323  - (0.12436676387548490*fabs(bL[56]))));\r\n\t\tinputSampleL += (bL[57] * (0.06241531553254467  - (0.11530779547021434*fabs(bL[57]))));\r\n\t\tinputSampleL += (bL[58] * (0.04952694587101836  - (0.08340945324333944*fabs(bL[58]))));\r\n\t\tinputSampleL += (bL[59] * (0.00843873294401687  - (0.03279659052562903*fabs(bL[59]))));\r\n\t\tinputSampleL -= (bL[60] * (0.05161338949440241  - (0.03428181149163798*fabs(bL[60]))));\r\n\t\tinputSampleL -= (bL[61] * (0.08165520146902012  - (0.08196746092283110*fabs(bL[61]))));\r\n\t\tinputSampleL -= (bL[62] * (0.06639532849935320  - (0.09797462781896329*fabs(bL[62]))));\r\n\t\tinputSampleL -= (bL[63] * (0.02953430910661621  - (0.09175612938515763*fabs(bL[63]))));\r\n\t\tinputSampleL += (bL[64] * (0.00741058547442938  + (0.05442091048731967*fabs(bL[64]))));\r\n\t\tinputSampleL += (bL[65] * (0.01832866125391727  + (0.00306243693643687*fabs(bL[65]))));\r\n\t\tinputSampleL += (bL[66] * (0.00526964230373573  - (0.04364102661136410*fabs(bL[66]))));\r\n\t\tinputSampleL -= (bL[67] * (0.00300984373848200  + (0.09742737841278880*fabs(bL[67]))));\r\n\t\tinputSampleL -= (bL[68] * (0.00413616769576694  + (0.14380661694523073*fabs(bL[68]))));\r\n\t\tinputSampleL -= (bL[69] * (0.00588769034931419  + (0.16012843578892538*fabs(bL[69]))));\r\n\t\tinputSampleL -= (bL[70] * (0.00688588239450581  + (0.14074464279305798*fabs(bL[70]))));\r\n\t\tinputSampleL -= (bL[71] * (0.02277307992926315  + (0.07914752191801366*fabs(bL[71]))));\r\n\t\tinputSampleL -= (bL[72] * (0.04627166091180877  - (0.00192787268067208*fabs(bL[72]))));\r\n\t\tinputSampleL -= (bL[73] * (0.05562045897455786  - (0.05932868727665747*fabs(bL[73]))));\r\n\t\tinputSampleL -= (bL[74] * (0.05134243784922165  - (0.08245334798868090*fabs(bL[74]))));\r\n\t\tinputSampleL -= (bL[75] * (0.04719409472239919  - (0.07498680629253825*fabs(bL[75]))));\r\n\t\tinputSampleL -= (bL[76] * (0.05889738914266415  - (0.06116127018043697*fabs(bL[76]))));\r\n\t\tinputSampleL -= (bL[77] * (0.09428363535111127  - (0.06535868867863834*fabs(bL[77]))));\r\n\t\tinputSampleL -= (bL[78] * (0.15181756953225126  - (0.08982979655234427*fabs(bL[78]))));\r\n\t\tinputSampleL -= (bL[79] * (0.20878969456036670  - (0.10761070891499538*fabs(bL[79]))));\r\n\t\tinputSampleL -= (bL[80] * (0.22647885581813790  - (0.08462542510349125*fabs(bL[80]))));\r\n\t\tinputSampleL -= (bL[81] * (0.19723482443646323  - (0.02665160920736287*fabs(bL[81]))));\r\n\t\tinputSampleL -= (bL[82] * (0.16441643451155163  + (0.02314691954338197*fabs(bL[82]))));\r\n\t\tinputSampleL -= (bL[83] * (0.15201914054931515  + (0.04424903493886839*fabs(bL[83]))));\r\n\t\tinputSampleL -= (bL[84] * (0.15454370641307855  + (0.04223203797913008*fabs(bL[84]))));\r\n\t\t\t\t\t\r\n\t\ttemp = (inputSampleL + smoothCabBL)/3.0;\r\n\t\tsmoothCabBL = inputSampleL;\r\n\t\tinputSampleL = temp/4.0;\r\n\t\t\r\n\t\trandy = (((double)(fpdL)/0xffffffff)*0.057);\r\n\t\tdrySampleL = ((inputSampleL*(1-randy))+(lastCabSampleL*randy))*outputlevel;\r\n\t\tlastCabSampleL = inputSampleL;\r\n\t\tinputSampleL = drySampleL; //cab L\r\n\t\t\r\n\t\ttemp = (inputSampleR + smoothCabAR)/3.0;\r\n\t\tsmoothCabAR = inputSampleR;\r\n\t\tinputSampleR = temp;\r\n\t\t\r\n\t\tbR[84] = bR[83]; bR[83] = bR[82]; bR[82] = bR[81]; bR[81] = bR[80]; bR[80] = bR[79]; \r\n\t\tbR[79] = bR[78]; bR[78] = bR[77]; bR[77] = bR[76]; bR[76] = bR[75]; bR[75] = bR[74]; bR[74] = bR[73]; bR[73] = bR[72]; bR[72] = bR[71]; \r\n\t\tbR[71] = bR[70]; bR[70] = bR[69]; bR[69] = bR[68]; bR[68] = bR[67]; bR[67] = bR[66]; bR[66] = bR[65]; bR[65] = bR[64]; bR[64] = bR[63]; \r\n\t\tbR[63] = bR[62]; bR[62] = bR[61]; bR[61] = bR[60]; bR[60] = bR[59]; bR[59] = bR[58]; bR[58] = bR[57]; bR[57] = bR[56]; bR[56] = bR[55]; \r\n\t\tbR[55] = bR[54]; bR[54] = bR[53]; bR[53] = bR[52]; bR[52] = bR[51]; bR[51] = bR[50]; bR[50] = bR[49]; bR[49] = bR[48]; bR[48] = bR[47]; \r\n\t\tbR[47] = bR[46]; bR[46] = bR[45]; bR[45] = bR[44]; bR[44] = bR[43]; bR[43] = bR[42]; bR[42] = bR[41]; bR[41] = bR[40]; bR[40] = bR[39]; \r\n\t\tbR[39] = bR[38]; bR[38] = bR[37]; bR[37] = bR[36]; bR[36] = bR[35]; bR[35] = bR[34]; bR[34] = bR[33]; bR[33] = bR[32]; bR[32] = bR[31]; \r\n\t\tbR[31] = bR[30]; bR[30] = bR[29]; bR[29] = bR[28]; bR[28] = bR[27]; bR[27] = bR[26]; bR[26] = bR[25]; bR[25] = bR[24]; bR[24] = bR[23]; \r\n\t\tbR[23] = bR[22]; bR[22] = bR[21]; bR[21] = bR[20]; bR[20] = bR[19]; bR[19] = bR[18]; bR[18] = bR[17]; bR[17] = bR[16]; bR[16] = bR[15]; \r\n\t\tbR[15] = bR[14]; bR[14] = bR[13]; bR[13] = bR[12]; bR[12] = bR[11]; bR[11] = bR[10]; bR[10] = bR[9]; bR[9] = bR[8]; bR[8] = bR[7]; \r\n\t\tbR[7] = bR[6]; bR[6] = bR[5]; bR[5] = bR[4]; bR[4] = bR[3]; bR[3] = bR[2]; bR[2] = bR[1]; bR[1] = bR[0]; bR[0] = inputSampleR;\r\n\t\tinputSampleR += (bR[1] * (1.31698250313308396  - (0.08140616497621633*fabs(bR[1]))));\r\n\t\tinputSampleR += (bR[2] * (1.47229016949915326  - (0.27680278993637253*fabs(bR[2]))));\r\n\t\tinputSampleR += (bR[3] * (1.30410109086044956  - (0.35629113432046489*fabs(bR[3]))));\r\n\t\tinputSampleR += (bR[4] * (0.81766210474551260  - (0.26808782337659753*fabs(bR[4]))));\r\n\t\tinputSampleR += (bR[5] * (0.19868872545506663  - (0.11105517193919669*fabs(bR[5]))));\r\n\t\tinputSampleR -= (bR[6] * (0.39115909132567039  - (0.12630622002682679*fabs(bR[6]))));\r\n\t\tinputSampleR -= (bR[7] * (0.76881891559343574  - (0.40879849500403143*fabs(bR[7]))));\r\n\t\tinputSampleR -= (bR[8] * (0.87146861782680340  - (0.59529560488000599*fabs(bR[8]))));\r\n\t\tinputSampleR -= (bR[9] * (0.79504575932563670  - (0.60877047551611796*fabs(bR[9]))));\r\n\t\tinputSampleR -= (bR[10] * (0.61653017622406314  - (0.47662851438557335*fabs(bR[10]))));\r\n\t\tinputSampleR -= (bR[11] * (0.40718195794382067  - (0.24955839378539713*fabs(bR[11]))));\r\n\t\tinputSampleR -= (bR[12] * (0.31794900040616203  - (0.04169792259600613*fabs(bR[12]))));\r\n\t\tinputSampleR -= (bR[13] * (0.41075032540217843  + (0.00368483996076280*fabs(bR[13]))));\r\n\t\tinputSampleR -= (bR[14] * (0.56901352922170667  - (0.11027360805893105*fabs(bR[14]))));\r\n\t\tinputSampleR -= (bR[15] * (0.62443222391889264  - (0.22198075154245228*fabs(bR[15]))));\r\n\t\tinputSampleR -= (bR[16] * (0.53462856723129204  - (0.22933544545324852*fabs(bR[16]))));\r\n\t\tinputSampleR -= (bR[17] * (0.34441703361995046  - (0.12956809502269492*fabs(bR[17]))));\r\n\t\tinputSampleR -= (bR[18] * (0.13947052337867882  + (0.00339775055962799*fabs(bR[18]))));\r\n\t\tinputSampleR += (bR[19] * (0.03771252648928484  - (0.10863931549251718*fabs(bR[19]))));\r\n\t\tinputSampleR += (bR[20] * (0.18280210770271693  - (0.17413646599296417*fabs(bR[20]))));\r\n\t\tinputSampleR += (bR[21] * (0.24621986701761467  - (0.14547053270435095*fabs(bR[21]))));\r\n\t\tinputSampleR += (bR[22] * (0.22347075142737360  - (0.02493869490104031*fabs(bR[22]))));\r\n\t\tinputSampleR += (bR[23] * (0.14346348482123716  + (0.11284054747963246*fabs(bR[23]))));\r\n\t\tinputSampleR += (bR[24] * (0.00834364862916028  + (0.24284684053733926*fabs(bR[24]))));\r\n\t\tinputSampleR -= (bR[25] * (0.11559740296078347  - (0.32623054435304538*fabs(bR[25]))));\r\n\t\tinputSampleR -= (bR[26] * (0.18067604561283060  - (0.32311481551122478*fabs(bR[26]))));\r\n\t\tinputSampleR -= (bR[27] * (0.22927997789035612  - (0.26991539052832925*fabs(bR[27]))));\r\n\t\tinputSampleR -= (bR[28] * (0.28487666578669446  - (0.22437227250279349*fabs(bR[28]))));\r\n\t\tinputSampleR -= (bR[29] * (0.31992973037153838  - (0.15289876100963865*fabs(bR[29]))));\r\n\t\tinputSampleR -= (bR[30] * (0.35174606303520733  - (0.05656293023086628*fabs(bR[30]))));\r\n\t\tinputSampleR -= (bR[31] * (0.36894898011375254  + (0.04333925421463558*fabs(bR[31]))));\r\n\t\tinputSampleR -= (bR[32] * (0.32567576055307507  + (0.14594589410921388*fabs(bR[32]))));\r\n\t\tinputSampleR -= (bR[33] * (0.27440135050585784  + (0.15529667398122521*fabs(bR[33]))));\r\n\t\tinputSampleR -= (bR[34] * (0.21998973785078091  + (0.05083553737157104*fabs(bR[34]))));\r\n\t\tinputSampleR -= (bR[35] * (0.10323624876862457  - (0.04651829594199963*fabs(bR[35]))));\r\n\t\tinputSampleR += (bR[36] * (0.02091603687851074  + (0.12000046818439322*fabs(bR[36]))));\r\n\t\tinputSampleR += (bR[37] * (0.11344930914138468  + (0.17697142512225839*fabs(bR[37]))));\r\n\t\tinputSampleR += (bR[38] * (0.22766779627643968  + (0.13645102964003858*fabs(bR[38]))));\r\n\t\tinputSampleR += (bR[39] * (0.38378309953638229  - (0.01997653307333791*fabs(bR[39]))));\r\n\t\tinputSampleR += (bR[40] * (0.52789400804568076  - (0.21409137428422448*fabs(bR[40]))));\r\n\t\tinputSampleR += (bR[41] * (0.55444630296938280  - (0.32331980931576626*fabs(bR[41]))));\r\n\t\tinputSampleR += (bR[42] * (0.42333237669264601  - (0.26855847463044280*fabs(bR[42]))));\r\n\t\tinputSampleR += (bR[43] * (0.21942831522035078  - (0.12051365248820624*fabs(bR[43]))));\r\n\t\tinputSampleR -= (bR[44] * (0.00584169427830633  - (0.03706970171280329*fabs(bR[44]))));\r\n\t\tinputSampleR -= (bR[45] * (0.24279799124660351  - (0.17296440491477982*fabs(bR[45]))));\r\n\t\tinputSampleR -= (bR[46] * (0.40173760787507085  - (0.21717989835163351*fabs(bR[46]))));\r\n\t\tinputSampleR -= (bR[47] * (0.43930035724188155  - (0.16425928481378199*fabs(bR[47]))));\r\n\t\tinputSampleR -= (bR[48] * (0.41067765934041811  - (0.10390115786636855*fabs(bR[48]))));\r\n\t\tinputSampleR -= (bR[49] * (0.34409235547165967  - (0.07268159377411920*fabs(bR[49]))));\r\n\t\tinputSampleR -= (bR[50] * (0.26542883122568151  - (0.05483457497365785*fabs(bR[50]))));\r\n\t\tinputSampleR -= (bR[51] * (0.22024754776138800  - (0.06484897950087598*fabs(bR[51]))));\r\n\t\tinputSampleR -= (bR[52] * (0.20394367993632415  - (0.08746309731952180*fabs(bR[52]))));\r\n\t\tinputSampleR -= (bR[53] * (0.17565242431124092  - (0.07611309538078760*fabs(bR[53]))));\r\n\t\tinputSampleR -= (bR[54] * (0.10116623231246825  - (0.00642818706295112*fabs(bR[54]))));\r\n\t\tinputSampleR -= (bR[55] * (0.00782648272053632  + (0.08004141267685004*fabs(bR[55]))));\r\n\t\tinputSampleR += (bR[56] * (0.05059046006747323  - (0.12436676387548490*fabs(bR[56]))));\r\n\t\tinputSampleR += (bR[57] * (0.06241531553254467  - (0.11530779547021434*fabs(bR[57]))));\r\n\t\tinputSampleR += (bR[58] * (0.04952694587101836  - (0.08340945324333944*fabs(bR[58]))));\r\n\t\tinputSampleR += (bR[59] * (0.00843873294401687  - (0.03279659052562903*fabs(bR[59]))));\r\n\t\tinputSampleR -= (bR[60] * (0.05161338949440241  - (0.03428181149163798*fabs(bR[60]))));\r\n\t\tinputSampleR -= (bR[61] * (0.08165520146902012  - (0.08196746092283110*fabs(bR[61]))));\r\n\t\tinputSampleR -= (bR[62] * (0.06639532849935320  - (0.09797462781896329*fabs(bR[62]))));\r\n\t\tinputSampleR -= (bR[63] * (0.02953430910661621  - (0.09175612938515763*fabs(bR[63]))));\r\n\t\tinputSampleR += (bR[64] * (0.00741058547442938  + (0.05442091048731967*fabs(bR[64]))));\r\n\t\tinputSampleR += (bR[65] * (0.01832866125391727  + (0.00306243693643687*fabs(bR[65]))));\r\n\t\tinputSampleR += (bR[66] * (0.00526964230373573  - (0.04364102661136410*fabs(bR[66]))));\r\n\t\tinputSampleR -= (bR[67] * (0.00300984373848200  + (0.09742737841278880*fabs(bR[67]))));\r\n\t\tinputSampleR -= (bR[68] * (0.00413616769576694  + (0.14380661694523073*fabs(bR[68]))));\r\n\t\tinputSampleR -= (bR[69] * (0.00588769034931419  + (0.16012843578892538*fabs(bR[69]))));\r\n\t\tinputSampleR -= (bR[70] * (0.00688588239450581  + (0.14074464279305798*fabs(bR[70]))));\r\n\t\tinputSampleR -= (bR[71] * (0.02277307992926315  + (0.07914752191801366*fabs(bR[71]))));\r\n\t\tinputSampleR -= (bR[72] * (0.04627166091180877  - (0.00192787268067208*fabs(bR[72]))));\r\n\t\tinputSampleR -= (bR[73] * (0.05562045897455786  - (0.05932868727665747*fabs(bR[73]))));\r\n\t\tinputSampleR -= (bR[74] * (0.05134243784922165  - (0.08245334798868090*fabs(bR[74]))));\r\n\t\tinputSampleR -= (bR[75] * (0.04719409472239919  - (0.07498680629253825*fabs(bR[75]))));\r\n\t\tinputSampleR -= (bR[76] * (0.05889738914266415  - (0.06116127018043697*fabs(bR[76]))));\r\n\t\tinputSampleR -= (bR[77] * (0.09428363535111127  - (0.06535868867863834*fabs(bR[77]))));\r\n\t\tinputSampleR -= (bR[78] * (0.15181756953225126  - (0.08982979655234427*fabs(bR[78]))));\r\n\t\tinputSampleR -= (bR[79] * (0.20878969456036670  - (0.10761070891499538*fabs(bR[79]))));\r\n\t\tinputSampleR -= (bR[80] * (0.22647885581813790  - (0.08462542510349125*fabs(bR[80]))));\r\n\t\tinputSampleR -= (bR[81] * (0.19723482443646323  - (0.02665160920736287*fabs(bR[81]))));\r\n\t\tinputSampleR -= (bR[82] * (0.16441643451155163  + (0.02314691954338197*fabs(bR[82]))));\r\n\t\tinputSampleR -= (bR[83] * (0.15201914054931515  + (0.04424903493886839*fabs(bR[83]))));\r\n\t\tinputSampleR -= (bR[84] * (0.15454370641307855  + (0.04223203797913008*fabs(bR[84]))));\r\n\t\t\r\n\t\ttemp = (inputSampleR + smoothCabBR)/3.0;\r\n\t\tsmoothCabBR = inputSampleR;\r\n\t\tinputSampleR = temp/4.0;\r\n\t\t\r\n\t\trandy = (((double)(fpdR)/0xffffffff)*0.057);\r\n\t\tdrySampleR = ((inputSampleR*(1.0-randy))+(lastCabSampleR*randy))*outputlevel;\r\n\t\tlastCabSampleR = inputSampleR;\r\n\t\tinputSampleR = drySampleR; //cab\r\n\t\t\r\n\t\tif (cycleEnd == 4) {\r\n\t\t\tlastRefL[0] = lastRefL[4]; //start from previous last\r\n\t\t\tlastRefL[2] = (lastRefL[0] + inputSampleL)/2; //half\r\n\t\t\tlastRefL[1] = (lastRefL[0] + lastRefL[2])/2; //one quarter\r\n\t\t\tlastRefL[3] = (lastRefL[2] + inputSampleL)/2; //three quarters\r\n\t\t\tlastRefL[4] = inputSampleL; //full\r\n\t\t\tlastRefR[0] = lastRefR[4]; //start from previous last\r\n\t\t\tlastRefR[2] = (lastRefR[0] + inputSampleR)/2; //half\r\n\t\t\tlastRefR[1] = (lastRefR[0] + lastRefR[2])/2; //one quarter\r\n\t\t\tlastRefR[3] = (lastRefR[2] + inputSampleR)/2; //three quarters\r\n\t\t\tlastRefR[4] = inputSampleR; //full\r\n\t\t}\r\n\t\tif (cycleEnd == 3) {\r\n\t\t\tlastRefL[0] = lastRefL[3]; //start from previous last\r\n\t\t\tlastRefL[2] = (lastRefL[0]+lastRefL[0]+inputSampleL)/3; //third\r\n\t\t\tlastRefL[1] = (lastRefL[0]+inputSampleL+inputSampleL)/3; //two thirds\r\n\t\t\tlastRefL[3] = inputSampleL; //full\r\n\t\t\tlastRefR[0] = lastRefR[3]; //start from previous last\r\n\t\t\tlastRefR[2] = (lastRefR[0]+lastRefR[0]+inputSampleR)/3; //third\r\n\t\t\tlastRefR[1] = (lastRefR[0]+inputSampleR+inputSampleR)/3; //two thirds\r\n\t\t\tlastRefR[3] = inputSampleR; //full\r\n\t\t}\r\n\t\tif (cycleEnd == 2) {\r\n\t\t\tlastRefL[0] = lastRefL[2]; //start from previous last\r\n\t\t\tlastRefL[1] = (lastRefL[0] + inputSampleL)/2; //half\r\n\t\t\tlastRefL[2] = inputSampleL; //full\r\n\t\t\tlastRefR[0] = lastRefR[2]; //start from previous last\r\n\t\t\tlastRefR[1] = (lastRefR[0] + inputSampleR)/2; //half\r\n\t\t\tlastRefR[2] = inputSampleR; //full\r\n\t\t}\r\n\t\tif (cycleEnd == 1) {\r\n\t\t\tlastRefL[0] = inputSampleL;\r\n\t\t\tlastRefR[0] = inputSampleR;\r\n\t\t}\r\n\t\tcycle = 0; //reset\r\n\t\tinputSampleL = lastRefL[cycle];\r\n\t\tinputSampleR = lastRefR[cycle];\r\n\t} else {\r\n\t\tinputSampleL = lastRefL[cycle];\r\n\t\tinputSampleR = lastRefR[cycle];\r\n\t\t//we are going through our references now\r\n\t}\r\n\tswitch (cycleEnd) //multi-pole average using lastRef[] variables\r\n\t{\r\n\t\tcase 4:\r\n\t\t\tlastRefL[8] = inputSampleL; inputSampleL = (inputSampleL+lastRefL[7])*0.5;\r\n\t\t\tlastRefL[7] = lastRefL[8]; //continue, do not break\r\n\t\t\tlastRefR[8] = inputSampleR; inputSampleR = (inputSampleR+lastRefR[7])*0.5;\r\n\t\t\tlastRefR[7] = lastRefR[8]; //continue, do not break\r\n\t\tcase 3:\r\n\t\t\tlastRefL[8] = inputSampleL; inputSampleL = (inputSampleL+lastRefL[6])*0.5;\r\n\t\t\tlastRefL[6] = lastRefL[8]; //continue, do not break\r\n\t\t\tlastRefR[8] = inputSampleR; inputSampleR = (inputSampleR+lastRefR[6])*0.5;\r\n\t\t\tlastRefR[6] = lastRefR[8]; //continue, do not break\r\n\t\tcase 2:\r\n\t\t\tlastRefL[8] = inputSampleL; inputSampleL = (inputSampleL+lastRefL[5])*0.5;\r\n\t\t\tlastRefL[5] = lastRefL[8]; //continue, do not break\r\n\t\t\tlastRefR[8] = inputSampleR; inputSampleR = (inputSampleR+lastRefR[5])*0.5;\r\n\t\t\tlastRefR[5] = lastRefR[8]; //continue, do not break\r\n\t\tcase 1:\r\n\t\t\tbreak; //no further averaging\r\n\t}\r\n\r\n\t//begin 32 bit stereo floating point dither\r\n\tint expon; frexpf((float)inputSampleL, &expon);\r\n\tfpdL ^= fpdL << 13; fpdL ^= fpdL >> 17; fpdL ^= fpdL << 5;\r\n\tinputSampleL += (((double)(fpdL)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\tfrexpf((float)inputSampleR, &expon);\r\n\tfpdR ^= fpdR << 13; fpdR ^= fpdR >> 17; fpdR ^= fpdR << 5;\r\n\tinputSampleR += (((double)(fpdR)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\t//end 32 bit stereo floating point dither\r\n\r\n\tStereo output;\r\n\toutput.left = inputSampleL;\r\n\toutput.right = inputSampleR;\r\n\t\r\n\treturn output;\r\n}\r\n","KnobDefaultValue3":"0.500000","KnobName5":"","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.500000","KnobName4":"...","KnobDefaultValue10":"0.500000","KnobDefaultValue5":"0.500000","KnobName7":"","KnobDefaultValue6":"0.500000","KnobName6":"","KnobDefaultValue7":"0.500000","KnobName9":"","KnobDefaultValue8":"0.500000","KnobName8":"","Name":"FireAmp (Airwindows)","KnobDefaultValue9":"0.500000","CompilationId":"ff0429ee-9d68-46dc-98de-b2962c0db70e","SwitchName1":"","SwitchDefaultValue0":"0","SwitchName0":"","SwitchDefaultValue1":"0","Description":"A bright, loud, tubey amp sim for leads and dirt guitar.","Created":"2022-Jun-24 23:52:41","LastModified":"2022-Jun-24 23:52:59","SwitchDefaultValue2":"0","SwitchName2":"","KnobName10":"","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"","FormulaName":""},"CStrip (Airwindows)":{"KnobName1":"Mid","KnobDefaultValue0":"0.500000","KnobName0":"Treble","KnobDefaultValue1":"0.500000","KnobName3":"Lowpass","KnobDefaultValue2":"0.500000","KnobName2":"Bass","Source":"/* ========================================\r\n *  CStrip - CStrip.h\r\n *  Copyright (c) 2016 airwindows, All rights reserved\r\n * ======================================== */\r\n\r\nuint32_t fpdL = 0xdeadbeef;\r\nuint32_t fpdR = 0xcafebabe;\r\n\r\n//default stuff\r\n\r\ndouble lastSampleL = 0;\r\ndouble last2SampleL = 0;\r\ndouble lastSampleR = 0;\r\ndouble last2SampleR = 0;\r\n\r\n//begin EQ\r\ndouble iirHighSampleLA = 0;\r\ndouble iirHighSampleLB = 0;\r\ndouble iirHighSampleLC = 0;\r\ndouble iirHighSampleLD = 0;\r\ndouble iirHighSampleLE = 0;\r\ndouble iirLowSampleLA = 0;\r\ndouble iirLowSampleLB = 0;\r\ndouble iirLowSampleLC = 0;\r\ndouble iirLowSampleLD = 0;\r\ndouble iirLowSampleLE = 0;\r\ndouble iirHighSampleL = 0;\r\ndouble iirLowSampleL = 0;\r\n\r\ndouble iirHighSampleRA = 0;\r\ndouble iirHighSampleRB = 0;\r\ndouble iirHighSampleRC = 0;\r\ndouble iirHighSampleRD = 0;\r\ndouble iirHighSampleRE = 0;\r\ndouble iirLowSampleRA = 0;\r\ndouble iirLowSampleRB = 0;\r\ndouble iirLowSampleRC = 0;\r\ndouble iirLowSampleRD = 0;\r\ndouble iirLowSampleRE = 0;\r\ndouble iirHighSampleR = 0;\r\ndouble iirLowSampleR = 0;\r\n\r\ndouble tripletLA = 0;\r\ndouble tripletLB = 0;\r\ndouble tripletLC = 0;\r\ndouble tripletFactorL = 0;\r\n\r\ndouble tripletRA = 0;\r\ndouble tripletRB = 0;\r\ndouble tripletRC = 0;\r\ndouble tripletFactorR = 0;\r\n\r\ndouble lowpassSampleLAA = 0;\r\ndouble lowpassSampleLAB = 0;\r\ndouble lowpassSampleLBA = 0;\r\ndouble lowpassSampleLBB = 0;\r\ndouble lowpassSampleLCA = 0;\r\ndouble lowpassSampleLCB = 0;\r\ndouble lowpassSampleLDA = 0;\r\ndouble lowpassSampleLDB = 0;\r\ndouble lowpassSampleLE = 0;\r\ndouble lowpassSampleLF = 0;\r\ndouble lowpassSampleLG = 0;\r\n\r\ndouble lowpassSampleRAA = 0;\r\ndouble lowpassSampleRAB = 0;\r\ndouble lowpassSampleRBA = 0;\r\ndouble lowpassSampleRBB = 0;\r\ndouble lowpassSampleRCA = 0;\r\ndouble lowpassSampleRCB = 0;\r\ndouble lowpassSampleRDA = 0;\r\ndouble lowpassSampleRDB = 0;\r\ndouble lowpassSampleRE = 0;\r\ndouble lowpassSampleRF = 0;\r\ndouble lowpassSampleRG = 0;\r\n\r\ndouble highpassSampleLAA = 0;\r\ndouble highpassSampleLAB = 0;\r\ndouble highpassSampleLBA = 0;\r\ndouble highpassSampleLBB = 0;\r\ndouble highpassSampleLCA = 0;\r\ndouble highpassSampleLCB = 0;\r\ndouble highpassSampleLDA = 0;\r\ndouble highpassSampleLDB = 0;\r\ndouble highpassSampleLE = 0;\r\ndouble highpassSampleLF = 0;\r\n\r\ndouble highpassSampleRAA = 0;\r\ndouble highpassSampleRAB = 0;\r\ndouble highpassSampleRBA = 0;\r\ndouble highpassSampleRBB = 0;\r\ndouble highpassSampleRCA = 0;\r\ndouble highpassSampleRCB = 0;\r\ndouble highpassSampleRDA = 0;\r\ndouble highpassSampleRDB = 0;\r\ndouble highpassSampleRE = 0;\r\ndouble highpassSampleRF = 0;\r\n\r\nint flip = 0;\r\nint flipthree = 0;\r\n//end EQ\r\n\r\n//begin Gate\r\nint WasNegativeL = 0;\r\nint ZeroCrossL = 0;\r\ndouble gaterollerL = 0;\r\ndouble gateL = 0;\r\n\r\nint WasNegativeR = 0;\r\nint ZeroCrossR = 0;\r\ndouble gaterollerR = 0;\r\ndouble gateR = 0;\r\n//end Gate\r\n\r\n//begin Timing\r\ndouble pL[4099] = {0};\r\ndouble pR[4099] = {0};\r\nint count = 0;\r\n//end Timing\r\n\r\n//begin ButterComp\r\ndouble controlAposL = 0;\r\ndouble controlAnegL = 0;\r\ndouble controlBposL = 0;\r\ndouble controlBnegL = 0;\r\ndouble targetposL = 0;\r\ndouble targetnegL = 0;\r\ndouble avgLA = 0;\r\ndouble avgLB = 0;\r\ndouble nvgLA = 0;\r\ndouble nvgLB = 0;\r\n\r\ndouble controlAposR = 0;\r\ndouble controlAnegR = 0;\r\ndouble controlBposR = 0;\r\ndouble controlBnegR = 0;\r\ndouble targetposR = 0;\r\ndouble targetnegR = 0;\r\ndouble avgRA = 0;\r\ndouble avgRB = 0;\r\ndouble nvgRA = 0;\r\ndouble nvgRB = 0;\r\n//end ButterComp\r\n//flip is already covered in EQ\n\nformula_main_stereo {\r\n\tdouble overallscale = 1.0;\r\n\toverallscale /= 44100.0;\r\n\tdouble compscale = overallscale;\r\n\toverallscale = SAMPLE_RATE;\r\n\tcompscale = compscale * overallscale;\r\n\t//compscale is the one that's 1 or something like 2.2 for 96K rates\r\n\tdouble fpOld = 0.618033988749894848204586; //golden ratio!\r\n\tdouble fpNew = 1.0 - fpOld;\r\n\tdouble inputSampleL;\r\n\tdouble inputSampleR;\r\n\r\n\tdouble highSampleL = 0.0;\r\n\tdouble midSampleL = 0.0;\r\n\tdouble bassSampleL = 0.0;\r\n\r\n\tdouble highSampleR = 0.0;\r\n\tdouble midSampleR = 0.0;\r\n\tdouble bassSampleR = 0.0;\r\n\r\n\tdouble densityA = (KNOB_1*12.0)-6.0;\r\n\tdouble densityB = (KNOB_2*12.0)-6.0;\r\n\tdouble densityC = (KNOB_3*12.0)-6.0;\r\n\tint engageEQ = 1;\r\n\tif ( (0.0 == densityA) && (0.0 == densityB) && (0.0 == densityC) ) engageEQ = 0;\r\n\r\n\tdensityA = pow(10.0,densityA/20.0)-1.0;\r\n\tdensityB = pow(10.0,densityB/20.0)-1.0;\r\n\tdensityC = pow(10.0,densityC/20.0)-1.0;\r\n\t//convert to 0 to X multiplier with 1.0 being O db\r\n\t//minus one gives nearly -1 to ? (should top out at 1)\r\n\t//calibrate so that X db roughly equals X db with maximum topping out at 1 internally\r\n\r\n\tdouble tripletIntensity = -densityA;\r\n\r\n\tdouble iirAmountC = (((KNOB_4*KNOB_4*15.0)+1.0)*0.0188) + 0.7;\r\n\tif (iirAmountC > 1.0) iirAmountC = 1.0;\r\n\tint engageLowpass = 0;\r\n\tif (((KNOB_4*KNOB_4*15.0)+1.0) < 15.99) engageLowpass = 1;\r\n\r\n\tdouble iirAmountA = (((KNOB_5*KNOB_5*15.0)+1.0)*1000)/overallscale;\r\n\tdouble iirAmountB = (((KNOB_6*KNOB_6*1570.0)+30.0)*10)/overallscale;\r\n\tdouble iirAmountD = (((KNOB_7*KNOB_7*1570.0)+30.0)*1.0)/overallscale;\r\n\tint engageHighpass = 0;\r\n\tif (((KNOB_7*KNOB_7*1570.0)+30.0) > 30.01) engageHighpass = 1;\r\n\t//bypass the highpass and lowpass if set to extremes\r\n\tdouble bridgerectifier;\r\n\tdouble outA = fabs(densityA);\r\n\tdouble outB = fabs(densityB);\r\n\tdouble outC = fabs(densityC);\r\n\t//end EQ\r\n\t//begin Gate\r\n\tdouble onthreshold = (pow(KNOB_8,4)/3)+0.00018;\r\n\tdouble offthreshold = onthreshold * 1.1;\r\n\tint engageGate = 0;\r\n\tif (onthreshold > 0.00018) engageGate = 1;\r\n\r\n\tdouble release = 0.028331119964586;\r\n\tdouble absmax = 220.9;\r\n\t//speed to be compensated w.r.t sample rate\r\n\t//end Gate\r\n\t//begin Timing\r\n\tdouble offset = pow(KNOB_11,5) * 700;\r\n\tint near = (int)floor(fabs(offset));\r\n\tdouble farLevel = fabs(offset) - near;\r\n\tint far = near + 1;\r\n\tdouble nearLevel = 1.0 - farLevel;\r\n\tint engageTiming = 0;\r\n\tif (offset > 0.0) engageTiming = 1;\r\n\t//end Timing\r\n\t//begin ButterComp\r\n\tdouble inputpos;\r\n\tdouble inputneg;\r\n\tdouble calcpos;\r\n\tdouble calcneg;\r\n\tdouble outputpos;\r\n\tdouble outputneg;\r\n\tdouble totalmultiplier;\r\n\tdouble inputgain = (pow(KNOB_9,4)*35)+1.0;\r\n\tdouble compoutgain = inputgain;\r\n\tcompoutgain -= 1.0;\r\n\tcompoutgain /= 1.2;\r\n\tcompoutgain += 1.0;\r\n\tdouble divisor = (0.008 * pow((0.01+KNOB_10),2))+0.0004;\r\n\t//originally 0.012\r\n\tdivisor /= compscale;\r\n\tdouble remainder = divisor;\r\n\tdivisor = 1.0 - divisor;\r\n\tint engageComp = 0;\r\n\tif (inputgain > 1.0) engageComp = 1;\r\n\t//end ButterComp\r\n\tdouble outputgain = pow(10.0,((KNOB_12*36.0)-18.0)/20.0);\r\n\r\n\r\n\tinputSampleL = input.left;\r\n\tinputSampleR = input.right;\r\n\tif (fabs(inputSampleL)<1.18e-23) inputSampleL = fpdL * 1.18e-17;\r\n\tif (fabs(inputSampleR)<1.18e-23) inputSampleR = fpdR * 1.18e-17;\r\n\t\r\n\tlast2SampleL = lastSampleL;\r\n\tlastSampleL = inputSampleL;\r\n\t\r\n\tlast2SampleR = lastSampleR;\r\n\tlastSampleR = inputSampleR;\r\n\t\r\n\t//begin Gate\r\n\tif (engageGate)\r\n\t{\r\n\t\tif (inputSampleL > 0)\r\n\t\t{if (WasNegativeL == 1){ZeroCrossL = absmax * 0.3;}\r\n\t\t\tWasNegativeL = 0;}\r\n\t\telse\r\n\t\t{ZeroCrossL += 1; WasNegativeL = 1;}\r\n\t\t\r\n\t\tif (inputSampleR > 0)\r\n\t\t{if (WasNegativeR == 1){ZeroCrossR = absmax * 0.3;}\r\n\t\t\tWasNegativeR = 0;}\r\n\t\telse\r\n\t\t{ZeroCrossR += 1; WasNegativeR = 1;}\r\n\t\t\r\n\t\tif (ZeroCrossL > absmax)\r\n\t\t{ZeroCrossL = absmax;}\r\n\t\t\r\n\t\tif (ZeroCrossR > absmax)\r\n\t\t{ZeroCrossR = absmax;}\r\n\t\t\r\n\t\tif (gateL == 0.0)\r\n\t\t{\r\n\t\t\t//if gate is totally silent\r\n\t\t\tif (fabs(inputSampleL) > onthreshold)\r\n\t\t\t{\r\n\t\t\t\tif (gaterollerL == 0.0) gaterollerL = ZeroCrossL;\r\n\t\t\t\telse gaterollerL -= release;\r\n\t\t\t\t// trigger from total silence only- if we're active then signal must clear offthreshold\r\n\t\t\t}\r\n\t\t\telse gaterollerL -= release;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//gate is not silent but closing\r\n\t\t\tif (fabs(inputSampleL) > offthreshold)\r\n\t\t\t{\r\n\t\t\t\tif (gaterollerL < ZeroCrossL) gaterollerL = ZeroCrossL;\r\n\t\t\t\telse gaterollerL -= release;\r\n\t\t\t\t//always trigger if gate is over offthreshold, otherwise close anyway\r\n\t\t\t}\r\n\t\t\telse gaterollerL -= release;\r\n\t\t}\r\n\r\n\t\tif (gateR == 0.0)\r\n\t\t{\r\n\t\t\t//if gate is totally silent\r\n\t\t\tif (fabs(inputSampleR) > onthreshold)\r\n\t\t\t{\r\n\t\t\t\tif (gaterollerR == 0.0) gaterollerR = ZeroCrossR;\r\n\t\t\t\telse gaterollerR -= release;\r\n\t\t\t\t// trigger from total silence only- if we're active then signal must clear offthreshold\r\n\t\t\t}\r\n\t\t\telse gaterollerR -= release;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//gate is not silent but closing\r\n\t\t\tif (fabs(inputSampleR) > offthreshold)\r\n\t\t\t{\r\n\t\t\t\tif (gaterollerR < ZeroCrossR) gaterollerR = ZeroCrossR;\r\n\t\t\t\telse gaterollerR -= release;\r\n\t\t\t\t//always trigger if gate is over offthreshold, otherwise close anyway\r\n\t\t\t}\r\n\t\t\telse gaterollerR -= release;\r\n\t\t}\r\n\t\t\r\n\t\tif (gaterollerL < 0.0)\r\n\t\t{gaterollerL = 0.0;}\r\n\t\tif (gaterollerR < 0.0)\r\n\t\t{gaterollerR = 0.0;}\r\n\t\t\r\n\t\tif (gaterollerL < 1.0)\r\n\t\t{\r\n\t\t\tgateL = gaterollerL;\r\n\t\t\tbridgerectifier = 1-cos(fabs(inputSampleL));\t\t\t\r\n\t\t\tif (inputSampleL > 0) inputSampleL = (inputSampleL*gateL)+(bridgerectifier*(1.0-gateL));\r\n\t\t\telse inputSampleL = (inputSampleL*gateL)-(bridgerectifier*(1.0-gateL));\r\n\t\t\tif (gateL == 0.0) inputSampleL = 0.0;\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{gateL = 1.0;}\r\n\r\n\t\tif (gaterollerR < 1.0)\r\n\t\t{\r\n\t\t\tgateR = gaterollerR;\r\n\t\t\tbridgerectifier = 1-cos(fabs(inputSampleR));\t\t\t\r\n\t\t\tif (inputSampleR > 0) inputSampleR = (inputSampleR*gateR)+(bridgerectifier*(1.0-gateR));\r\n\t\t\telse inputSampleR = (inputSampleR*gateR)-(bridgerectifier*(1.0-gateR));\r\n\t\t\tif (gateR == 0.0) inputSampleR = 0.0;\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{gateR = 1.0;}\r\n\t}\r\n\t//end Gate, begin antialiasing\r\n\t\r\n\tflip = !flip;\r\n\tflipthree++;\r\n\tif (flipthree < 1 || flipthree > 3) flipthree = 1;\r\n\t//counters\r\n\t\r\n\t//begin highpass\r\n\tif (engageHighpass)\r\n\t{\r\n\t\tif (flip)\r\n\t\t{\r\n\t\t\thighpassSampleLAA = (highpassSampleLAA * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLAA;\r\n\t\t\thighpassSampleLBA = (highpassSampleLBA * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLBA;\r\n\t\t\thighpassSampleLCA = (highpassSampleLCA * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLCA;\r\n\t\t\thighpassSampleLDA = (highpassSampleLDA * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLDA;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thighpassSampleLAB = (highpassSampleLAB * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLAB;\r\n\t\t\thighpassSampleLBB = (highpassSampleLBB * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLBB;\r\n\t\t\thighpassSampleLCB = (highpassSampleLCB * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLCB;\r\n\t\t\thighpassSampleLDB = (highpassSampleLDB * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\t\tinputSampleL -= highpassSampleLDB;\r\n\t\t}\r\n\t\thighpassSampleLE = (highpassSampleLE * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\tinputSampleL -= highpassSampleLE;\r\n\t\thighpassSampleLF = (highpassSampleLF * (1.0 - iirAmountD)) + (inputSampleL * iirAmountD);\r\n\t\tinputSampleL -= highpassSampleLF;\t\t\t\r\n\t\t\r\n\t\tif (flip)\r\n\t\t{\r\n\t\t\thighpassSampleRAA = (highpassSampleRAA * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRAA;\r\n\t\t\thighpassSampleRBA = (highpassSampleRBA * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRBA;\r\n\t\t\thighpassSampleRCA = (highpassSampleRCA * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRCA;\r\n\t\t\thighpassSampleRDA = (highpassSampleRDA * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRDA;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\thighpassSampleRAB = (highpassSampleRAB * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRAB;\r\n\t\t\thighpassSampleRBB = (highpassSampleRBB * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRBB;\r\n\t\t\thighpassSampleRCB = (highpassSampleRCB * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRCB;\r\n\t\t\thighpassSampleRDB = (highpassSampleRDB * (1.0 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\t\tinputSampleR -= highpassSampleRDB;\r\n\t\t}\r\n\t\thighpassSampleRE = (highpassSampleRE * (1 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\tinputSampleR -= highpassSampleRE;\r\n\t\thighpassSampleRF = (highpassSampleRF * (1 - iirAmountD)) + (inputSampleR * iirAmountD);\r\n\t\tinputSampleR -= highpassSampleRF;\t\t\t\r\n\t\t\r\n\t}\r\n\t//end highpass \r\n\t\r\n\t//begin compressor\r\n\tif (engageComp)\r\n\t{\r\n\t\t//begin L\r\n\t\tinputSampleL *= inputgain;\r\n\t\t\r\n\t\tinputpos = (inputSampleL * fpOld) + (avgLA * fpNew) + 1.0;\r\n\t\tavgLA = inputSampleL;\r\n\t\t\r\n\t\tif (inputpos < 0.0) inputpos = 0.0;\r\n\t\toutputpos = inputpos / 2.0;\r\n\t\tif (outputpos > 1.0) outputpos = 1.0;\t\t\r\n\t\tinputpos *= inputpos;\r\n\t\ttargetposL *= divisor;\r\n\t\ttargetposL += (inputpos * remainder);\r\n\t\tcalcpos = pow((1.0/targetposL),2);\r\n\t\t\r\n\t\tinputneg = (-inputSampleL * fpOld) + (nvgLA * fpNew) + 1.0;\r\n\t\tnvgLA = -inputSampleL;\r\n\t\t\r\n\t\tif (inputneg < 0.0) inputneg = 0.0;\r\n\t\toutputneg = inputneg / 2.0;\r\n\t\tif (outputneg > 1.0) outputneg = 1.0;\t\t\r\n\t\tinputneg *= inputneg;\r\n\t\ttargetnegL *= divisor;\r\n\t\ttargetnegL += (inputneg * remainder);\r\n\t\tcalcneg = pow((1.0/targetnegL),2);\r\n\t\t//now we have mirrored targets for comp\r\n\t\t//outputpos and outputneg go from 0 to 1\r\n\t\t\r\n\t\tif (inputSampleL > 0)\r\n\t\t{ //working on pos\r\n\t\t\tif (1 == flip)\r\n\t\t\t{\r\n\t\t\t\tcontrolAposL *= divisor;\r\n\t\t\t\tcontrolAposL += (calcpos*remainder);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcontrolBposL *= divisor;\r\n\t\t\t\tcontrolBposL += (calcpos*remainder);\r\n\t\t\t}\t\r\n\t\t}\r\n\t\telse\r\n\t\t{ //working on neg\r\n\t\t\tif (1 == flip)\r\n\t\t\t{\r\n\t\t\t\tcontrolAnegL *= divisor;\r\n\t\t\t\tcontrolAnegL += (calcneg*remainder);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcontrolBnegL *= divisor;\r\n\t\t\t\tcontrolBnegL += (calcneg*remainder);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//this causes each of the four to update only when active and in the correct 'flip'\r\n\t\t\r\n\t\tif (1 == flip)\r\n\t\t{totalmultiplier = (controlAposL * outputpos) + (controlAnegL * outputneg);}\r\n\t\telse\r\n\t\t{totalmultiplier = (controlBposL * outputpos) + (controlBnegL * outputneg);}\r\n\t\t//this combines the sides according to flip, blending relative to the input value\r\n\t\t\r\n\t\tinputSampleL *= totalmultiplier;\r\n\t\tinputSampleL /= compoutgain;\r\n\t\t//end L\r\n\t\t\r\n\t\t//begin R\r\n\t\tinputSampleR *= inputgain;\r\n\t\t\r\n\t\tinputpos = (inputSampleR * fpOld) + (avgRA * fpNew) + 1.0;\r\n\t\tavgRA = inputSampleR;\r\n\t\t\r\n\t\tif (inputpos < 0.0) inputpos = 0.0;\r\n\t\toutputpos = inputpos / 2.0;\r\n\t\tif (outputpos > 1.0) outputpos = 1.0;\t\t\r\n\t\tinputpos *= inputpos;\r\n\t\ttargetposR *= divisor;\r\n\t\ttargetposR += (inputpos * remainder);\r\n\t\tcalcpos = pow((1.0/targetposR),2);\r\n\t\t\r\n\t\tinputneg = (-inputSampleR * fpOld) + (nvgRA * fpNew) + 1.0;\r\n\t\tnvgRA = -inputSampleR;\r\n\t\t\r\n\t\tif (inputneg < 0.0) inputneg = 0.0;\r\n\t\toutputneg = inputneg / 2.0;\r\n\t\tif (outputneg > 1.0) outputneg = 1.0;\t\t\r\n\t\tinputneg *= inputneg;\r\n\t\ttargetnegR *= divisor;\r\n\t\ttargetnegR += (inputneg * remainder);\r\n\t\tcalcneg = pow((1.0/targetnegR),2);\r\n\t\t//now we have mirrored targets for comp\r\n\t\t//outputpos and outputneg go from 0 to 1\r\n\t\t\r\n\t\tif (inputSampleR > 0)\r\n\t\t{ //working on pos\r\n\t\t\tif (1 == flip)\r\n\t\t\t{\r\n\t\t\t\tcontrolAposR *= divisor;\r\n\t\t\t\tcontrolAposR += (calcpos*remainder);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcontrolBposR *= divisor;\r\n\t\t\t\tcontrolBposR += (calcpos*remainder);\r\n\t\t\t}\t\r\n\t\t}\r\n\t\telse\r\n\t\t{ //working on neg\r\n\t\t\tif (1 == flip)\r\n\t\t\t{\r\n\t\t\t\tcontrolAnegR *= divisor;\r\n\t\t\t\tcontrolAnegR += (calcneg*remainder);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcontrolBnegR *= divisor;\r\n\t\t\t\tcontrolBnegR += (calcneg*remainder);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//this causes each of the four to update only when active and in the correct 'flip'\r\n\t\t\r\n\t\tif (1 == flip)\r\n\t\t{totalmultiplier = (controlAposR * outputpos) + (controlAnegR * outputneg);}\r\n\t\telse\r\n\t\t{totalmultiplier = (controlBposR * outputpos) + (controlBnegR * outputneg);}\r\n\t\t//this combines the sides according to flip, blending relative to the input value\r\n\t\t\r\n\t\tinputSampleR *= totalmultiplier;\r\n\t\tinputSampleR /= compoutgain;\r\n\t\t//end R\r\n\t}\r\n\t//end compressor\r\n\t\r\n\t//begin EQ\r\n\tif (engageEQ)\r\n\t{\r\n\t\tswitch (flipthree)\r\n\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\ttripletFactorL = last2SampleL - inputSampleL;\r\n\t\t\t\ttripletLA += tripletFactorL;\r\n\t\t\t\ttripletLC -= tripletFactorL;\r\n\t\t\t\ttripletFactorL = tripletLA * tripletIntensity;\r\n\t\t\t\tiirHighSampleLC = (iirHighSampleLC * (1.0 - iirAmountA)) + (inputSampleL * iirAmountA);\r\n\t\t\t\thighSampleL = inputSampleL - iirHighSampleLC;\r\n\t\t\t\tiirLowSampleLC = (iirLowSampleLC * (1.0 - iirAmountB)) + (inputSampleL * iirAmountB);\r\n\t\t\t\tbassSampleL = iirLowSampleLC;\r\n\r\n\t\t\t\ttripletFactorR = last2SampleR - inputSampleR;\r\n\t\t\t\ttripletRA += tripletFactorR;\r\n\t\t\t\ttripletRC -= tripletFactorR;\r\n\t\t\t\ttripletFactorR = tripletRA * tripletIntensity;\r\n\t\t\t\tiirHighSampleRC = (iirHighSampleRC * (1.0 - iirAmountA)) + (inputSampleR * iirAmountA);\r\n\t\t\t\thighSampleR = inputSampleR - iirHighSampleRC;\r\n\t\t\t\tiirLowSampleRC = (iirLowSampleRC * (1.0 - iirAmountB)) + (inputSampleR * iirAmountB);\r\n\t\t\t\tbassSampleR = iirLowSampleRC;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\ttripletFactorL = last2SampleL - inputSampleL;\r\n\t\t\t\ttripletLB += tripletFactorL;\r\n\t\t\t\ttripletLA -= tripletFactorL;\r\n\t\t\t\ttripletFactorL = tripletLB * tripletIntensity;\r\n\t\t\t\tiirHighSampleLD = (iirHighSampleLD * (1.0 - iirAmountA)) + (inputSampleL * iirAmountA);\r\n\t\t\t\thighSampleL = inputSampleL - iirHighSampleLD;\r\n\t\t\t\tiirLowSampleLD = (iirLowSampleLD * (1.0 - iirAmountB)) + (inputSampleL * iirAmountB);\r\n\t\t\t\tbassSampleL = iirLowSampleLD;\r\n\r\n\t\t\t\ttripletFactorR = last2SampleR - inputSampleR;\r\n\t\t\t\ttripletRB += tripletFactorR;\r\n\t\t\t\ttripletRA -= tripletFactorR;\r\n\t\t\t\ttripletFactorR = tripletRB * tripletIntensity;\r\n\t\t\t\tiirHighSampleRD = (iirHighSampleRD * (1.0 - iirAmountA)) + (inputSampleR * iirAmountA);\r\n\t\t\t\thighSampleR = inputSampleR - iirHighSampleRD;\r\n\t\t\t\tiirLowSampleRD = (iirLowSampleRD * (1.0 - iirAmountB)) + (inputSampleR * iirAmountB);\r\n\t\t\t\tbassSampleR = iirLowSampleRD;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\ttripletFactorL = last2SampleL - inputSampleL;\r\n\t\t\t\ttripletLC += tripletFactorL;\r\n\t\t\t\ttripletLB -= tripletFactorL;\r\n\t\t\t\ttripletFactorL = tripletLC * tripletIntensity;\r\n\t\t\t\tiirHighSampleLE = (iirHighSampleLE * (1.0 - iirAmountA)) + (inputSampleL * iirAmountA);\r\n\t\t\t\thighSampleL = inputSampleL - iirHighSampleLE;\r\n\t\t\t\tiirLowSampleLE = (iirLowSampleLE * (1.0 - iirAmountB)) + (inputSampleL * iirAmountB);\r\n\t\t\t\tbassSampleL = iirLowSampleLE;\r\n\r\n\t\t\t\ttripletFactorR = last2SampleR - inputSampleR;\r\n\t\t\t\ttripletRC += tripletFactorR;\r\n\t\t\t\ttripletRB -= tripletFactorR;\r\n\t\t\t\ttripletFactorR = tripletRC * tripletIntensity;\r\n\t\t\t\tiirHighSampleRE = (iirHighSampleRE * (1.0 - iirAmountA)) + (inputSampleR * iirAmountA);\r\n\t\t\t\thighSampleR = inputSampleR - iirHighSampleRE;\r\n\t\t\t\tiirLowSampleRE = (iirLowSampleRE * (1.0 - iirAmountB)) + (inputSampleR * iirAmountB);\r\n\t\t\t\tbassSampleR = iirLowSampleRE;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\ttripletLA /= 2.0;\r\n\t\ttripletLB /= 2.0;\r\n\t\ttripletLC /= 2.0;\r\n\t\thighSampleL = highSampleL + tripletFactorL;\r\n\r\n\t\ttripletRA /= 2.0;\r\n\t\ttripletRB /= 2.0;\r\n\t\ttripletRC /= 2.0;\r\n\t\thighSampleR = highSampleR + tripletFactorR;\r\n\t\t\r\n\t\tif (flip)\r\n\t\t{\r\n\t\t\tiirHighSampleLA = (iirHighSampleLA * (1.0 - iirAmountA)) + (highSampleL * iirAmountA);\r\n\t\t\thighSampleL -= iirHighSampleLA;\r\n\t\t\tiirLowSampleLA = (iirLowSampleLA * (1.0 - iirAmountB)) + (bassSampleL * iirAmountB);\r\n\t\t\tbassSampleL = iirLowSampleLA;\r\n\r\n\t\t\tiirHighSampleRA = (iirHighSampleRA * (1.0 - iirAmountA)) + (highSampleR * iirAmountA);\r\n\t\t\thighSampleR -= iirHighSampleRA;\r\n\t\t\tiirLowSampleRA = (iirLowSampleRA * (1.0 - iirAmountB)) + (bassSampleR * iirAmountB);\r\n\t\t\tbassSampleR = iirLowSampleRA;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tiirHighSampleLB = (iirHighSampleLB * (1.0 - iirAmountA)) + (highSampleL * iirAmountA);\r\n\t\t\thighSampleL -= iirHighSampleLB;\r\n\t\t\tiirLowSampleLB = (iirLowSampleLB * (1.0 - iirAmountB)) + (bassSampleL * iirAmountB);\r\n\t\t\tbassSampleL = iirLowSampleLB;\r\n\r\n\t\t\tiirHighSampleRB = (iirHighSampleRB * (1.0 - iirAmountA)) + (highSampleR * iirAmountA);\r\n\t\t\thighSampleR -= iirHighSampleRB;\r\n\t\t\tiirLowSampleRB = (iirLowSampleRB * (1.0 - iirAmountB)) + (bassSampleR * iirAmountB);\r\n\t\t\tbassSampleR = iirLowSampleRB;\r\n\t\t}\r\n\t\t\r\n\t\tiirHighSampleL = (iirHighSampleL * (1.0 - iirAmountA)) + (highSampleL * iirAmountA);\r\n\t\thighSampleL -= iirHighSampleL;\r\n\t\tiirLowSampleL = (iirLowSampleL * (1.0 - iirAmountB)) + (bassSampleL * iirAmountB);\r\n\t\tbassSampleL = iirLowSampleL;\r\n\r\n\t\tiirHighSampleR = (iirHighSampleR * (1.0 - iirAmountA)) + (highSampleR * iirAmountA);\r\n\t\thighSampleR -= iirHighSampleR;\r\n\t\tiirLowSampleR = (iirLowSampleR * (1.0 - iirAmountB)) + (bassSampleR * iirAmountB);\r\n\t\tbassSampleR = iirLowSampleR;\r\n\t\t\r\n\t\tmidSampleL = (inputSampleL-bassSampleL)-highSampleL;\r\n\t\tmidSampleR = (inputSampleR-bassSampleR)-highSampleR;\r\n\r\n\t\t//drive section\r\n\t\thighSampleL *= (densityA+1.0);\r\n\t\tbridgerectifier = fabs(highSampleL)*1.57079633;\r\n\t\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\t\t//max value for sine function\r\n\t\tif (densityA > 0) bridgerectifier = sin(bridgerectifier);\r\n\t\telse bridgerectifier = 1-cos(bridgerectifier);\r\n\t\t//produce either boosted or starved version\r\n\t\tif (highSampleL > 0) highSampleL = (highSampleL*(1-outA))+(bridgerectifier*outA);\r\n\t\telse highSampleL = (highSampleL*(1-outA))-(bridgerectifier*outA);\r\n\t\t//blend according to densityA control\r\n\t\t\r\n\t\thighSampleR *= (densityA+1.0);\r\n\t\tbridgerectifier = fabs(highSampleR)*1.57079633;\r\n\t\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\t\t//max value for sine function\r\n\t\tif (densityA > 0) bridgerectifier = sin(bridgerectifier);\r\n\t\telse bridgerectifier = 1-cos(bridgerectifier);\r\n\t\t//produce either boosted or starved version\r\n\t\tif (highSampleR > 0) highSampleR = (highSampleR*(1-outA))+(bridgerectifier*outA);\r\n\t\telse highSampleR = (highSampleR*(1-outA))-(bridgerectifier*outA);\r\n\t\t//blend according to densityA control\r\n\t\t\r\n\t\tmidSampleL *= (densityB+1.0);\r\n\t\tbridgerectifier = fabs(midSampleL)*1.57079633;\r\n\t\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\t\t//max value for sine function\r\n\t\tif (densityB > 0) bridgerectifier = sin(bridgerectifier);\r\n\t\telse bridgerectifier = 1-cos(bridgerectifier);\r\n\t\t//produce either boosted or starved version\r\n\t\tif (midSampleL > 0) midSampleL = (midSampleL*(1-outB))+(bridgerectifier*outB);\r\n\t\telse midSampleL = (midSampleL*(1-outB))-(bridgerectifier*outB);\r\n\t\t//blend according to densityB control\r\n\t\t\r\n\t\tmidSampleR *= (densityB+1.0);\r\n\t\tbridgerectifier = fabs(midSampleR)*1.57079633;\r\n\t\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\t\t//max value for sine function\r\n\t\tif (densityB > 0) bridgerectifier = sin(bridgerectifier);\r\n\t\telse bridgerectifier = 1-cos(bridgerectifier);\r\n\t\t//produce either boosted or starved version\r\n\t\tif (midSampleR > 0) midSampleR = (midSampleR*(1-outB))+(bridgerectifier*outB);\r\n\t\telse midSampleR = (midSampleR*(1-outB))-(bridgerectifier*outB);\r\n\t\t//blend according to densityB control\r\n\t\t\r\n\t\tbassSampleL *= (densityC+1.0);\r\n\t\tbridgerectifier = fabs(bassSampleL)*1.57079633;\r\n\t\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\t\t//max value for sine function\r\n\t\tif (densityC > 0) bridgerectifier = sin(bridgerectifier);\r\n\t\telse bridgerectifier = 1-cos(bridgerectifier);\r\n\t\t//produce either boosted or starved version\r\n\t\tif (bassSampleL > 0) bassSampleL = (bassSampleL*(1-outC))+(bridgerectifier*outC);\r\n\t\telse bassSampleL = (bassSampleL*(1-outC))-(bridgerectifier*outC);\r\n\t\t//blend according to densityC control\r\n\t\t\r\n\t\tbassSampleR *= (densityC+1.0);\r\n\t\tbridgerectifier = fabs(bassSampleR)*1.57079633;\r\n\t\tif (bridgerectifier > 1.57079633) bridgerectifier = 1.57079633;\r\n\t\t//max value for sine function\r\n\t\tif (densityC > 0) bridgerectifier = sin(bridgerectifier);\r\n\t\telse bridgerectifier = 1-cos(bridgerectifier);\r\n\t\t//produce either boosted or starved version\r\n\t\tif (bassSampleR > 0) bassSampleR = (bassSampleR*(1-outC))+(bridgerectifier*outC);\r\n\t\telse bassSampleR = (bassSampleR*(1-outC))-(bridgerectifier*outC);\r\n\t\t//blend according to densityC control\r\n\t\t\r\n\t\tinputSampleL = midSampleL;\r\n\t\tinputSampleL += highSampleL;\r\n\t\tinputSampleL += bassSampleL;\r\n\r\n\t\tinputSampleR = midSampleR;\r\n\t\tinputSampleR += highSampleR;\r\n\t\tinputSampleR += bassSampleR;\r\n\t}\r\n\t//end EQ\r\n\t\r\n\t//begin Timing\r\n\tif (engageTiming = 1)\r\n\t{\r\n\t\tif (count < 1 || count > 2048) count = 2048;\r\n\t\t\r\n\t\tpL[count+2048] = pL[count] = inputSampleL;\r\n\t\tpR[count+2048] = pR[count] = inputSampleR;\r\n\r\n\t\tinputSampleL = pL[count+near]*nearLevel;\r\n\t\tinputSampleR = pR[count+near]*nearLevel;\r\n\r\n\t\tinputSampleL += pL[count+far]*farLevel;\r\n\t\tinputSampleR += pR[count+far]*farLevel;\r\n\r\n\t\tcount -= 1;\r\n\t\t//consider adding third sample just to bring out superhighs subtly, like old interpolation hacks\r\n\t\t//or third and fifth samples, ditto\t\t\r\n\t}\r\n\t//end Timing\r\n\t\r\n\t//EQ lowpass is after all processing like the compressor that might produce hash\r\n\tif (engageLowpass)\r\n\t{\r\n\t\tif (flip)\r\n\t\t{\r\n\t\t\tlowpassSampleLAA = (lowpassSampleLAA * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLAA;\r\n\t\t\tlowpassSampleLBA = (lowpassSampleLBA * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLBA;\r\n\t\t\tlowpassSampleLCA = (lowpassSampleLCA * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLCA;\r\n\t\t\tlowpassSampleLDA = (lowpassSampleLDA * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLDA;\r\n\t\t\tlowpassSampleLE = (lowpassSampleLE * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLE;\r\n\r\n\t\t\tlowpassSampleRAA = (lowpassSampleRAA * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRAA;\r\n\t\t\tlowpassSampleRBA = (lowpassSampleRBA * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRBA;\r\n\t\t\tlowpassSampleRCA = (lowpassSampleRCA * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRCA;\r\n\t\t\tlowpassSampleRDA = (lowpassSampleRDA * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRDA;\r\n\t\t\tlowpassSampleRE = (lowpassSampleRE * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRE;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlowpassSampleLAB = (lowpassSampleLAB * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLAB;\r\n\t\t\tlowpassSampleLBB = (lowpassSampleLBB * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLBB;\r\n\t\t\tlowpassSampleLCB = (lowpassSampleLCB * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLCB;\r\n\t\t\tlowpassSampleLDB = (lowpassSampleLDB * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLDB;\r\n\t\t\tlowpassSampleLF = (lowpassSampleLF * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\t\tinputSampleL = lowpassSampleLF;\t\t\t\r\n\r\n\t\t\tlowpassSampleRAB = (lowpassSampleRAB * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRAB;\r\n\t\t\tlowpassSampleRBB = (lowpassSampleRBB * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRBB;\r\n\t\t\tlowpassSampleRCB = (lowpassSampleRCB * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRCB;\r\n\t\t\tlowpassSampleRDB = (lowpassSampleRDB * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRDB;\r\n\t\t\tlowpassSampleRF = (lowpassSampleRF * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\tinputSampleR = lowpassSampleRF;\t\t\t\r\n\t\t}\r\n\t\tlowpassSampleLG = (lowpassSampleLG * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\tlowpassSampleRG = (lowpassSampleRG * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t\t\r\n\t\tinputSampleL = (lowpassSampleLG * (1.0 - iirAmountC)) + (inputSampleL * iirAmountC);\r\n\t\tinputSampleR = (lowpassSampleRG * (1.0 - iirAmountC)) + (inputSampleR * iirAmountC);\r\n\t}\r\n\t\r\n\t//built in output trim and dry/wet if desired\r\n\tif (outputgain != 1.0) {\r\n\t\tinputSampleL *= outputgain;\r\n\t\tinputSampleR *= outputgain;\r\n\t}\r\n\t\r\n\t//begin 32 bit stereo floating point dither\r\n\tint expon; frexpf((float)inputSampleL, &expon);\r\n\tfpdL ^= fpdL << 13; fpdL ^= fpdL >> 17; fpdL ^= fpdL << 5;\r\n\tinputSampleL += (((double)(fpdL)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\tfrexpf((float)inputSampleR, &expon);\r\n\tfpdR ^= fpdR << 13; fpdR ^= fpdR >> 17; fpdR ^= fpdR << 5;\r\n\tinputSampleR += (((double)(fpdR)-(uint32_t)(0x7fffffff)) * 5.5e-36l * pow(2,expon+62));\r\n\t//end 32 bit stereo floating point dither\r\n\r\n\tStereo output;\r\n\toutput.left = inputSampleL;\r\n\toutput.right = inputSampleR;\r\n\t\r\n\treturn output;\n}\n","KnobDefaultValue3":"1.000000","KnobName5":"Bass Freq","KnobDefaultValue11":"0.500000","KnobDefaultValue4":"0.600000","KnobName4":"Treble Freq","KnobDefaultValue10":"0.000000","KnobDefaultValue5":"0.300000","KnobName7":"Gate","KnobDefaultValue6":"0.000000","KnobName6":"Highpass","KnobDefaultValue7":"0.000000","KnobName9":"Comp Speed","KnobDefaultValue8":"0.000000","KnobName8":"Compression","Name":"CStrip (Airwindows)","KnobDefaultValue9":"0.500000","CompilationId":"9d5348ee-9ef3-48dd-b98d-62dc9df517b1","SwitchName1":"","SwitchDefaultValue0":"0","SwitchName0":"","SwitchDefaultValue1":"0","Description":"An Airwindows channel strip, with sort of the usual things you might find there.","Created":"2022-Jun-24 23:49:51","LastModified":"2022-Jun-25 00:43:45","SwitchDefaultValue2":"0","SwitchName2":"","KnobName10":"Timing Lag","FormulaSource":"\nformula_main {\n    float output = input;\n    return output;\n}\n","KnobName11":"Output Gain","FormulaName":""}}